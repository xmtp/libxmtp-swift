// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(xmtpv3FFI)
    import xmtpv3FFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len: 0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_xmtpv3_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_xmtpv3_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        lock()
        defer { self.unlock() }
        return try f()
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_UNEXPECTED_ERROR: Int8 = 2
private let CALL_CANCELLED: Int8 = 3

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T
) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
    case CALL_SUCCESS:
        return

    case CALL_ERROR:
        if let errorHandler = errorHandler {
            throw try errorHandler(callStatus.errorBuf)
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.unexpectedRustCallError
        }

    case CALL_UNEXPECTED_ERROR:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    case CALL_CANCELLED:
        fatalError("Cancellation not supported yet")

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> Void
) {
    do {
        try writeReturn(makeCall())
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> Void,
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

    func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        map.count
    }
}

// Public interface members begin here.

private struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

private struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return try Data(readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

public protocol FfiConversationsProtocol: AnyObject {
    func createGroup(accountAddresses: [String], opts: FfiCreateGroupOptions) async throws -> FfiGroup

    func list(opts: FfiListConversationsOptions) async throws -> [FfiGroup]

    func processStreamedWelcomeMessage(envelopeBytes: Data) async throws -> FfiGroup

    func stream(callback: FfiConversationCallback) async -> FfiStreamCloser

    func streamAllMessages(messageCallback: FfiMessageCallback) async -> FfiStreamCloser

    func sync() async throws

    func syncAllGroups() async throws -> UInt32
}

open class FfiConversations:
    FfiConversationsProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_fficonversations(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_fficonversations(pointer, $0) }
    }

    open func createGroup(accountAddresses: [String], opts: FfiCreateGroupOptions) async throws -> FfiGroup {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_fficonversations_create_group(
                        self.uniffiClonePointer(),
                        FfiConverterSequenceString.lower(accountAddresses), FfiConverterTypeFfiCreateGroupOptions.lower(opts)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
                completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
                freeFunc: ffi_xmtpv3_rust_future_free_pointer,
                liftFunc: FfiConverterTypeFfiGroup.lift,
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func list(opts: FfiListConversationsOptions) async throws -> [FfiGroup] {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_fficonversations_list(
                        self.uniffiClonePointer(),
                        FfiConverterTypeFfiListConversationsOptions.lower(opts)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
                completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
                freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
                liftFunc: FfiConverterSequenceTypeFfiGroup.lift,
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func processStreamedWelcomeMessage(envelopeBytes: Data) async throws -> FfiGroup {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_fficonversations_process_streamed_welcome_message(
                        self.uniffiClonePointer(),
                        FfiConverterData.lower(envelopeBytes)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
                completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
                freeFunc: ffi_xmtpv3_rust_future_free_pointer,
                liftFunc: FfiConverterTypeFfiGroup.lift,
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func stream(callback: FfiConversationCallback) async -> FfiStreamCloser {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_fficonversations_stream(
                        self.uniffiClonePointer(),
                        FfiConverterCallbackInterfaceFfiConversationCallback.lower(callback)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
                completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
                freeFunc: ffi_xmtpv3_rust_future_free_pointer,
                liftFunc: FfiConverterTypeFfiStreamCloser.lift,
                errorHandler: nil
            )
    }

    open func streamAllMessages(messageCallback: FfiMessageCallback) async -> FfiStreamCloser {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_fficonversations_stream_all_messages(
                        self.uniffiClonePointer(),
                        FfiConverterCallbackInterfaceFfiMessageCallback.lower(messageCallback)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
                completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
                freeFunc: ffi_xmtpv3_rust_future_free_pointer,
                liftFunc: FfiConverterTypeFfiStreamCloser.lift,
                errorHandler: nil
            )
    }

    open func sync() async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_fficonversations_sync(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func syncAllGroups() async throws -> UInt32 {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_fficonversations_sync_all_groups(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_u32,
                completeFunc: ffi_xmtpv3_rust_future_complete_u32,
                freeFunc: ffi_xmtpv3_rust_future_free_u32,
                liftFunc: FfiConverterUInt32.lift,
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }
}

public struct FfiConverterTypeFfiConversations: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiConversations

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConversations {
        return FfiConversations(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiConversations) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConversations {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiConversations, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFfiConversations_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConversations {
    return try FfiConverterTypeFfiConversations.lift(pointer)
}

public func FfiConverterTypeFfiConversations_lower(_ value: FfiConversations) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiConversations.lower(value)
}

public protocol FfiGroupProtocol: AnyObject {
    func addAdmin(inboxId: String) async throws

    func addMembers(accountAddresses: [String]) async throws

    func addMembersByInboxId(inboxIds: [String]) async throws

    func addSuperAdmin(inboxId: String) async throws

    func addedByInboxId() throws -> String

    func adminList() throws -> [String]

    func consentState() throws -> FfiConsentState

    func createdAtNs() -> Int64

    func findMessages(opts: FfiListMessagesOptions) throws -> [FfiMessage]

    func groupDescription() throws -> String

    func groupImageUrlSquare() throws -> String

    func groupMetadata() throws -> FfiGroupMetadata

    func groupName() throws -> String

    func groupPermissions() throws -> FfiGroupPermissions

    func groupPinnedFrameUrl() throws -> String

    func id() -> Data

    func isActive() throws -> Bool

    func isAdmin(inboxId: String) throws -> Bool

    func isSuperAdmin(inboxId: String) throws -> Bool

    func listMembers() throws -> [FfiGroupMember]

    func processStreamedGroupMessage(envelopeBytes: Data) async throws -> FfiMessage

    /**
     * Publish all unpublished messages
     */
    func publishMessages() async throws

    func removeAdmin(inboxId: String) async throws

    func removeMembers(accountAddresses: [String]) async throws

    func removeMembersByInboxId(inboxIds: [String]) async throws

    func removeSuperAdmin(inboxId: String) async throws

    func send(contentBytes: Data) async throws -> Data

    /**
     * send a message without immediately publishing to the delivery service.
     */
    func sendOptimistic(contentBytes: Data) throws -> Data

    func stream(messageCallback: FfiMessageCallback) async -> FfiStreamCloser

    func superAdminList() throws -> [String]

    func sync() async throws

    func updateConsentState(state: FfiConsentState) throws

    func updateGroupDescription(groupDescription: String) async throws

    func updateGroupImageUrlSquare(groupImageUrlSquare: String) async throws

    func updateGroupName(groupName: String) async throws

    func updateGroupPinnedFrameUrl(pinnedFrameUrl: String) async throws

    func updatePermissionPolicy(permissionUpdateType: FfiPermissionUpdateType, permissionPolicyOption: FfiPermissionPolicy, metadataField: FfiMetadataField?) async throws
}

open class FfiGroup:
    FfiGroupProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffigroup(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffigroup(pointer, $0) }
    }

    open func addAdmin(inboxId: String) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffigroup_add_admin(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(inboxId)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func addMembers(accountAddresses: [String]) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffigroup_add_members(
                        self.uniffiClonePointer(),
                        FfiConverterSequenceString.lower(accountAddresses)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func addMembersByInboxId(inboxIds: [String]) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffigroup_add_members_by_inbox_id(
                        self.uniffiClonePointer(),
                        FfiConverterSequenceString.lower(inboxIds)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func addSuperAdmin(inboxId: String) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffigroup_add_super_admin(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(inboxId)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func addedByInboxId() throws -> String {
        return try FfiConverterString.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_method_ffigroup_added_by_inbox_id(self.uniffiClonePointer(), $0)
        })
    }

    open func adminList() throws -> [String] {
        return try FfiConverterSequenceString.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_method_ffigroup_admin_list(self.uniffiClonePointer(), $0)
        })
    }

    open func consentState() throws -> FfiConsentState {
        return try FfiConverterTypeFfiConsentState.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_method_ffigroup_consent_state(self.uniffiClonePointer(), $0)
        })
    }

    open func createdAtNs() -> Int64 {
        return try! FfiConverterInt64.lift(try! rustCall {
            uniffi_xmtpv3_fn_method_ffigroup_created_at_ns(self.uniffiClonePointer(), $0)
        })
    }

    open func findMessages(opts: FfiListMessagesOptions) throws -> [FfiMessage] {
        return try FfiConverterSequenceTypeFfiMessage.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_method_ffigroup_find_messages(self.uniffiClonePointer(),
                                                           FfiConverterTypeFfiListMessagesOptions.lower(opts), $0)
        })
    }

    open func groupDescription() throws -> String {
        return try FfiConverterString.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_method_ffigroup_group_description(self.uniffiClonePointer(), $0)
        })
    }

    open func groupImageUrlSquare() throws -> String {
        return try FfiConverterString.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_method_ffigroup_group_image_url_square(self.uniffiClonePointer(), $0)
        })
    }

    open func groupMetadata() throws -> FfiGroupMetadata {
        return try FfiConverterTypeFfiGroupMetadata.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_method_ffigroup_group_metadata(self.uniffiClonePointer(), $0)
        })
    }

    open func groupName() throws -> String {
        return try FfiConverterString.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_method_ffigroup_group_name(self.uniffiClonePointer(), $0)
        })
    }

    open func groupPermissions() throws -> FfiGroupPermissions {
        return try FfiConverterTypeFfiGroupPermissions.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_method_ffigroup_group_permissions(self.uniffiClonePointer(), $0)
        })
    }

    open func groupPinnedFrameUrl() throws -> String {
        return try FfiConverterString.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_method_ffigroup_group_pinned_frame_url(self.uniffiClonePointer(), $0)
        })
    }

    open func id() -> Data {
        return try! FfiConverterData.lift(try! rustCall {
            uniffi_xmtpv3_fn_method_ffigroup_id(self.uniffiClonePointer(), $0)
        })
    }

    open func isActive() throws -> Bool {
        return try FfiConverterBool.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_method_ffigroup_is_active(self.uniffiClonePointer(), $0)
        })
    }

    open func isAdmin(inboxId: String) throws -> Bool {
        return try FfiConverterBool.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_method_ffigroup_is_admin(self.uniffiClonePointer(),
                                                      FfiConverterString.lower(inboxId), $0)
        })
    }

    open func isSuperAdmin(inboxId: String) throws -> Bool {
        return try FfiConverterBool.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_method_ffigroup_is_super_admin(self.uniffiClonePointer(),
                                                            FfiConverterString.lower(inboxId), $0)
        })
    }

    open func listMembers() throws -> [FfiGroupMember] {
        return try FfiConverterSequenceTypeFfiGroupMember.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_method_ffigroup_list_members(self.uniffiClonePointer(), $0)
        })
    }

    open func processStreamedGroupMessage(envelopeBytes: Data) async throws -> FfiMessage {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffigroup_process_streamed_group_message(
                        self.uniffiClonePointer(),
                        FfiConverterData.lower(envelopeBytes)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
                completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
                freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeFfiMessage.lift,
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    /**
     * Publish all unpublished messages
     */
    open func publishMessages() async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffigroup_publish_messages(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func removeAdmin(inboxId: String) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffigroup_remove_admin(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(inboxId)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func removeMembers(accountAddresses: [String]) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffigroup_remove_members(
                        self.uniffiClonePointer(),
                        FfiConverterSequenceString.lower(accountAddresses)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func removeMembersByInboxId(inboxIds: [String]) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffigroup_remove_members_by_inbox_id(
                        self.uniffiClonePointer(),
                        FfiConverterSequenceString.lower(inboxIds)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func removeSuperAdmin(inboxId: String) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffigroup_remove_super_admin(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(inboxId)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func send(contentBytes: Data) async throws -> Data {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffigroup_send(
                        self.uniffiClonePointer(),
                        FfiConverterData.lower(contentBytes)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
                completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
                freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
                liftFunc: FfiConverterData.lift,
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    /**
     * send a message without immediately publishing to the delivery service.
     */
    open func sendOptimistic(contentBytes: Data) throws -> Data {
        return try FfiConverterData.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_method_ffigroup_send_optimistic(self.uniffiClonePointer(),
                                                             FfiConverterData.lower(contentBytes), $0)
        })
    }

    open func stream(messageCallback: FfiMessageCallback) async -> FfiStreamCloser {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffigroup_stream(
                        self.uniffiClonePointer(),
                        FfiConverterCallbackInterfaceFfiMessageCallback.lower(messageCallback)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
                completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
                freeFunc: ffi_xmtpv3_rust_future_free_pointer,
                liftFunc: FfiConverterTypeFfiStreamCloser.lift,
                errorHandler: nil
            )
    }

    open func superAdminList() throws -> [String] {
        return try FfiConverterSequenceString.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_method_ffigroup_super_admin_list(self.uniffiClonePointer(), $0)
        })
    }

    open func sync() async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffigroup_sync(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func updateConsentState(state: FfiConsentState) throws { try rustCallWithError(FfiConverterTypeGenericError.lift) {
        uniffi_xmtpv3_fn_method_ffigroup_update_consent_state(self.uniffiClonePointer(),
                                                              FfiConverterTypeFfiConsentState.lower(state), $0)
    }
    }

    open func updateGroupDescription(groupDescription: String) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffigroup_update_group_description(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(groupDescription)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func updateGroupImageUrlSquare(groupImageUrlSquare: String) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffigroup_update_group_image_url_square(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(groupImageUrlSquare)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func updateGroupName(groupName: String) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffigroup_update_group_name(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(groupName)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func updateGroupPinnedFrameUrl(pinnedFrameUrl: String) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffigroup_update_group_pinned_frame_url(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(pinnedFrameUrl)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func updatePermissionPolicy(permissionUpdateType: FfiPermissionUpdateType, permissionPolicyOption: FfiPermissionPolicy, metadataField: FfiMetadataField?) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffigroup_update_permission_policy(
                        self.uniffiClonePointer(),
                        FfiConverterTypeFfiPermissionUpdateType.lower(permissionUpdateType), FfiConverterTypeFfiPermissionPolicy.lower(permissionPolicyOption), FfiConverterOptionTypeFfiMetadataField.lower(metadataField)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }
}

public struct FfiConverterTypeFfiGroup: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiGroup

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiGroup {
        return FfiGroup(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiGroup) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiGroup {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiGroup, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFfiGroup_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiGroup {
    return try FfiConverterTypeFfiGroup.lift(pointer)
}

public func FfiConverterTypeFfiGroup_lower(_ value: FfiGroup) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiGroup.lower(value)
}

public protocol FfiGroupMetadataProtocol: AnyObject {
    func conversationType() -> String

    func creatorInboxId() -> String
}

open class FfiGroupMetadata:
    FfiGroupMetadataProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffigroupmetadata(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffigroupmetadata(pointer, $0) }
    }

    open func conversationType() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_xmtpv3_fn_method_ffigroupmetadata_conversation_type(self.uniffiClonePointer(), $0)
        })
    }

    open func creatorInboxId() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_xmtpv3_fn_method_ffigroupmetadata_creator_inbox_id(self.uniffiClonePointer(), $0)
        })
    }
}

public struct FfiConverterTypeFfiGroupMetadata: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiGroupMetadata

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiGroupMetadata {
        return FfiGroupMetadata(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiGroupMetadata) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiGroupMetadata {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiGroupMetadata, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFfiGroupMetadata_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiGroupMetadata {
    return try FfiConverterTypeFfiGroupMetadata.lift(pointer)
}

public func FfiConverterTypeFfiGroupMetadata_lower(_ value: FfiGroupMetadata) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiGroupMetadata.lower(value)
}

public protocol FfiGroupPermissionsProtocol: AnyObject {
    func policySet() throws -> FfiPermissionPolicySet

    func policyType() throws -> FfiGroupPermissionsOptions
}

open class FfiGroupPermissions:
    FfiGroupPermissionsProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffigrouppermissions(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffigrouppermissions(pointer, $0) }
    }

    open func policySet() throws -> FfiPermissionPolicySet {
        return try FfiConverterTypeFfiPermissionPolicySet.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_method_ffigrouppermissions_policy_set(self.uniffiClonePointer(), $0)
        })
    }

    open func policyType() throws -> FfiGroupPermissionsOptions {
        return try FfiConverterTypeFfiGroupPermissionsOptions.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_method_ffigrouppermissions_policy_type(self.uniffiClonePointer(), $0)
        })
    }
}

public struct FfiConverterTypeFfiGroupPermissions: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiGroupPermissions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiGroupPermissions {
        return FfiGroupPermissions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiGroupPermissions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiGroupPermissions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiGroupPermissions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFfiGroupPermissions_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiGroupPermissions {
    return try FfiConverterTypeFfiGroupPermissions.lift(pointer)
}

public func FfiConverterTypeFfiGroupPermissions_lower(_ value: FfiGroupPermissions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiGroupPermissions.lower(value)
}

public protocol FfiSignatureRequestProtocol: AnyObject {
    func addEcdsaSignature(signatureBytes: Data) async throws

    func addScwSignature(signatureBytes: Data, address: String, chainId: UInt64, blockNumber: UInt64) async throws

    func isReady() async -> Bool

    /**
     * missing signatures that are from [MemberKind::Address]
     */
    func missingAddressSignatures() async throws -> [String]

    func signatureText() async throws -> String
}

open class FfiSignatureRequest:
    FfiSignatureRequestProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffisignaturerequest(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffisignaturerequest(pointer, $0) }
    }

    open func addEcdsaSignature(signatureBytes: Data) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffisignaturerequest_add_ecdsa_signature(
                        self.uniffiClonePointer(),
                        FfiConverterData.lower(signatureBytes)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func addScwSignature(signatureBytes: Data, address: String, chainId: UInt64, blockNumber: UInt64) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffisignaturerequest_add_scw_signature(
                        self.uniffiClonePointer(),
                        FfiConverterData.lower(signatureBytes), FfiConverterString.lower(address), FfiConverterUInt64.lower(chainId), FfiConverterUInt64.lower(blockNumber)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func isReady() async -> Bool {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffisignaturerequest_is_ready(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_i8,
                completeFunc: ffi_xmtpv3_rust_future_complete_i8,
                freeFunc: ffi_xmtpv3_rust_future_free_i8,
                liftFunc: FfiConverterBool.lift,
                errorHandler: nil
            )
    }

    /**
     * missing signatures that are from [MemberKind::Address]
     */
    open func missingAddressSignatures() async throws -> [String] {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffisignaturerequest_missing_address_signatures(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
                completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
                freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
                liftFunc: FfiConverterSequenceString.lift,
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func signatureText() async throws -> String {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffisignaturerequest_signature_text(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
                completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
                freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
                liftFunc: FfiConverterString.lift,
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }
}

public struct FfiConverterTypeFfiSignatureRequest: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiSignatureRequest

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiSignatureRequest {
        return FfiSignatureRequest(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiSignatureRequest) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiSignatureRequest {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiSignatureRequest, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFfiSignatureRequest_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiSignatureRequest {
    return try FfiConverterTypeFfiSignatureRequest.lift(pointer)
}

public func FfiConverterTypeFfiSignatureRequest_lower(_ value: FfiSignatureRequest) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiSignatureRequest.lower(value)
}

public protocol FfiStreamCloserProtocol: AnyObject {
    /**
     * Signal the stream to end
     * Does not wait for the stream to end.
     */
    func end()

    /**
     * End the stream and asyncronously wait for it to shutdown
     */
    func endAndWait() async throws

    func isClosed() -> Bool
}

open class FfiStreamCloser:
    FfiStreamCloserProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffistreamcloser(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffistreamcloser(pointer, $0) }
    }

    /**
     * Signal the stream to end
     * Does not wait for the stream to end.
     */
    open func end() { try! rustCall {
        uniffi_xmtpv3_fn_method_ffistreamcloser_end(self.uniffiClonePointer(), $0)
    }
    }

    /**
     * End the stream and asyncronously wait for it to shutdown
     */
    open func endAndWait() async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffistreamcloser_end_and_wait(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func isClosed() -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_xmtpv3_fn_method_ffistreamcloser_is_closed(self.uniffiClonePointer(), $0)
        })
    }
}

public struct FfiConverterTypeFfiStreamCloser: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiStreamCloser

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiStreamCloser {
        return FfiStreamCloser(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiStreamCloser) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiStreamCloser {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiStreamCloser, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFfiStreamCloser_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiStreamCloser {
    return try FfiConverterTypeFfiStreamCloser.lift(pointer)
}

public func FfiConverterTypeFfiStreamCloser_lower(_ value: FfiStreamCloser) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiStreamCloser.lower(value)
}

public protocol FfiV2ApiClientProtocol: AnyObject {
    func batchQuery(req: FfiV2BatchQueryRequest) async throws -> FfiV2BatchQueryResponse

    func publish(request: FfiPublishRequest, authToken: String) async throws

    func query(request: FfiV2QueryRequest) async throws -> FfiV2QueryResponse

    func setAppVersion(version: String)

    func subscribe(request: FfiV2SubscribeRequest, callback: FfiV2SubscriptionCallback) async throws -> FfiV2Subscription
}

open class FfiV2ApiClient:
    FfiV2ApiClientProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffiv2apiclient(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffiv2apiclient(pointer, $0) }
    }

    open func batchQuery(req: FfiV2BatchQueryRequest) async throws -> FfiV2BatchQueryResponse {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffiv2apiclient_batch_query(
                        self.uniffiClonePointer(),
                        FfiConverterTypeFfiV2BatchQueryRequest.lower(req)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
                completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
                freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeFfiV2BatchQueryResponse.lift,
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func publish(request: FfiPublishRequest, authToken: String) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffiv2apiclient_publish(
                        self.uniffiClonePointer(),
                        FfiConverterTypeFfiPublishRequest.lower(request), FfiConverterString.lower(authToken)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func query(request: FfiV2QueryRequest) async throws -> FfiV2QueryResponse {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffiv2apiclient_query(
                        self.uniffiClonePointer(),
                        FfiConverterTypeFfiV2QueryRequest.lower(request)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
                completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
                freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeFfiV2QueryResponse.lift,
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func setAppVersion(version: String) { try! rustCall {
        uniffi_xmtpv3_fn_method_ffiv2apiclient_set_app_version(self.uniffiClonePointer(),
                                                               FfiConverterString.lower(version), $0)
    }
    }

    open func subscribe(request: FfiV2SubscribeRequest, callback: FfiV2SubscriptionCallback) async throws -> FfiV2Subscription {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffiv2apiclient_subscribe(
                        self.uniffiClonePointer(),
                        FfiConverterTypeFfiV2SubscribeRequest.lower(request), FfiConverterCallbackInterfaceFfiV2SubscriptionCallback.lower(callback)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
                completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
                freeFunc: ffi_xmtpv3_rust_future_free_pointer,
                liftFunc: FfiConverterTypeFfiV2Subscription.lift,
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }
}

public struct FfiConverterTypeFfiV2ApiClient: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiV2ApiClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiV2ApiClient {
        return FfiV2ApiClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiV2ApiClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiV2ApiClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiV2ApiClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFfiV2ApiClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiV2ApiClient {
    return try FfiConverterTypeFfiV2ApiClient.lift(pointer)
}

public func FfiConverterTypeFfiV2ApiClient_lower(_ value: FfiV2ApiClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiV2ApiClient.lower(value)
}

/**
 * Subscription to a stream of V2 Messages
 */
public protocol FfiV2SubscriptionProtocol: AnyObject {
    /**
     * End the subscription, waiting for the subscription to close entirely.
     * # Errors
     * * Errors if subscription event task encounters join error
     */
    func end() async throws

    /**
     * Check if the subscription is closed
     */
    func isClosed() -> Bool

    /**
     * Update subscription with new topics
     */
    func update(req: FfiV2SubscribeRequest) async throws
}

/**
 * Subscription to a stream of V2 Messages
 */
open class FfiV2Subscription:
    FfiV2SubscriptionProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffiv2subscription(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffiv2subscription(pointer, $0) }
    }

    /**
     * End the subscription, waiting for the subscription to close entirely.
     * # Errors
     * * Errors if subscription event task encounters join error
     */
    open func end() async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffiv2subscription_end(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    /**
     * Check if the subscription is closed
     */
    open func isClosed() -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_xmtpv3_fn_method_ffiv2subscription_is_closed(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Update subscription with new topics
     */
    open func update(req: FfiV2SubscribeRequest) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffiv2subscription_update(
                        self.uniffiClonePointer(),
                        FfiConverterTypeFfiV2SubscribeRequest.lower(req)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }
}

public struct FfiConverterTypeFfiV2Subscription: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiV2Subscription

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiV2Subscription {
        return FfiV2Subscription(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiV2Subscription) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiV2Subscription {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiV2Subscription, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFfiV2Subscription_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiV2Subscription {
    return try FfiConverterTypeFfiV2Subscription.lift(pointer)
}

public func FfiConverterTypeFfiV2Subscription_lower(_ value: FfiV2Subscription) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiV2Subscription.lower(value)
}

public protocol FfiXmtpClientProtocol: AnyObject {
    /**
     * Adds an identity - really a wallet address - to the existing client
     */
    func addWallet(existingWalletAddress: String, newWalletAddress: String) async throws -> FfiSignatureRequest

    func applySignatureRequest(signatureRequest: FfiSignatureRequest) async throws

    func canMessage(accountAddresses: [String]) async throws -> [String: Bool]

    func conversations() -> FfiConversations

    func dbReconnect() async throws

    func findInboxId(address: String) async throws -> String?

    func getConsentState(entityType: FfiConsentEntityType, entity: String) async throws -> FfiConsentState

    func getLatestInboxState(inboxId: String) async throws -> FfiInboxState

    func group(groupId: Data) throws -> FfiGroup

    func inboxId() -> String

    /**
     * * Get the client's inbox state.
     *      *
     *      * If `refresh_from_network` is true, the client will go to the network first to refresh the state.
     *      * Otherwise, the state will be read from the local database.
     */
    func inboxState(refreshFromNetwork: Bool) async throws -> FfiInboxState

    func installationId() -> Data

    func message(messageId: Data) throws -> FfiMessage

    func registerIdentity(signatureRequest: FfiSignatureRequest) async throws

    func releaseDbConnection() throws

    func requestHistorySync() async throws

    /**
     * * Revokes all installations except the one the client is currently using
     */
    func revokeAllOtherInstallations() async throws -> FfiSignatureRequest

    /**
     * Revokes or removes an identity - really a wallet address - from the existing client
     */
    func revokeWallet(walletAddress: String) async throws -> FfiSignatureRequest

    func setConsentState(state: FfiConsentState, entityType: FfiConsentEntityType, entity: String) async throws

    func signatureRequest() -> FfiSignatureRequest?
}

open class FfiXmtpClient:
    FfiXmtpClientProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_xmtpv3_fn_clone_ffixmtpclient(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_xmtpv3_fn_free_ffixmtpclient(pointer, $0) }
    }

    /**
     * Adds an identity - really a wallet address - to the existing client
     */
    open func addWallet(existingWalletAddress: String, newWalletAddress: String) async throws -> FfiSignatureRequest {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffixmtpclient_add_wallet(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(existingWalletAddress), FfiConverterString.lower(newWalletAddress)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
                completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
                freeFunc: ffi_xmtpv3_rust_future_free_pointer,
                liftFunc: FfiConverterTypeFfiSignatureRequest.lift,
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func applySignatureRequest(signatureRequest: FfiSignatureRequest) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffixmtpclient_apply_signature_request(
                        self.uniffiClonePointer(),
                        FfiConverterTypeFfiSignatureRequest.lower(signatureRequest)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func canMessage(accountAddresses: [String]) async throws -> [String: Bool] {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffixmtpclient_can_message(
                        self.uniffiClonePointer(),
                        FfiConverterSequenceString.lower(accountAddresses)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
                completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
                freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
                liftFunc: FfiConverterDictionaryStringBool.lift,
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func conversations() -> FfiConversations {
        return try! FfiConverterTypeFfiConversations.lift(try! rustCall {
            uniffi_xmtpv3_fn_method_ffixmtpclient_conversations(self.uniffiClonePointer(), $0)
        })
    }

    open func dbReconnect() async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffixmtpclient_db_reconnect(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func findInboxId(address: String) async throws -> String? {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffixmtpclient_find_inbox_id(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(address)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
                completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
                freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
                liftFunc: FfiConverterOptionString.lift,
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func getConsentState(entityType: FfiConsentEntityType, entity: String) async throws -> FfiConsentState {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffixmtpclient_get_consent_state(
                        self.uniffiClonePointer(),
                        FfiConverterTypeFfiConsentEntityType.lower(entityType), FfiConverterString.lower(entity)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
                completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
                freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeFfiConsentState.lift,
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func getLatestInboxState(inboxId: String) async throws -> FfiInboxState {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffixmtpclient_get_latest_inbox_state(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(inboxId)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
                completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
                freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeFfiInboxState.lift,
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func group(groupId: Data) throws -> FfiGroup {
        return try FfiConverterTypeFfiGroup.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_method_ffixmtpclient_group(self.uniffiClonePointer(),
                                                        FfiConverterData.lower(groupId), $0)
        })
    }

    open func inboxId() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_xmtpv3_fn_method_ffixmtpclient_inbox_id(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * * Get the client's inbox state.
     *      *
     *      * If `refresh_from_network` is true, the client will go to the network first to refresh the state.
     *      * Otherwise, the state will be read from the local database.
     */
    open func inboxState(refreshFromNetwork: Bool) async throws -> FfiInboxState {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffixmtpclient_inbox_state(
                        self.uniffiClonePointer(),
                        FfiConverterBool.lower(refreshFromNetwork)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
                completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
                freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeFfiInboxState.lift,
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func installationId() -> Data {
        return try! FfiConverterData.lift(try! rustCall {
            uniffi_xmtpv3_fn_method_ffixmtpclient_installation_id(self.uniffiClonePointer(), $0)
        })
    }

    open func message(messageId: Data) throws -> FfiMessage {
        return try FfiConverterTypeFfiMessage.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_method_ffixmtpclient_message(self.uniffiClonePointer(),
                                                          FfiConverterData.lower(messageId), $0)
        })
    }

    open func registerIdentity(signatureRequest: FfiSignatureRequest) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffixmtpclient_register_identity(
                        self.uniffiClonePointer(),
                        FfiConverterTypeFfiSignatureRequest.lower(signatureRequest)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func releaseDbConnection() throws { try rustCallWithError(FfiConverterTypeGenericError.lift) {
        uniffi_xmtpv3_fn_method_ffixmtpclient_release_db_connection(self.uniffiClonePointer(), $0)
    }
    }

    open func requestHistorySync() async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffixmtpclient_request_history_sync(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    /**
     * * Revokes all installations except the one the client is currently using
     */
    open func revokeAllOtherInstallations() async throws -> FfiSignatureRequest {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffixmtpclient_revoke_all_other_installations(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
                completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
                freeFunc: ffi_xmtpv3_rust_future_free_pointer,
                liftFunc: FfiConverterTypeFfiSignatureRequest.lift,
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    /**
     * Revokes or removes an identity - really a wallet address - from the existing client
     */
    open func revokeWallet(walletAddress: String) async throws -> FfiSignatureRequest {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffixmtpclient_revoke_wallet(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(walletAddress)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
                completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
                freeFunc: ffi_xmtpv3_rust_future_free_pointer,
                liftFunc: FfiConverterTypeFfiSignatureRequest.lift,
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func setConsentState(state: FfiConsentState, entityType: FfiConsentEntityType, entity: String) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_xmtpv3_fn_method_ffixmtpclient_set_consent_state(
                        self.uniffiClonePointer(),
                        FfiConverterTypeFfiConsentState.lower(state), FfiConverterTypeFfiConsentEntityType.lower(entityType), FfiConverterString.lower(entity)
                    )
                },
                pollFunc: ffi_xmtpv3_rust_future_poll_void,
                completeFunc: ffi_xmtpv3_rust_future_complete_void,
                freeFunc: ffi_xmtpv3_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeGenericError.lift
            )
    }

    open func signatureRequest() -> FfiSignatureRequest? {
        return try! FfiConverterOptionTypeFfiSignatureRequest.lift(try! rustCall {
            uniffi_xmtpv3_fn_method_ffixmtpclient_signature_request(self.uniffiClonePointer(), $0)
        })
    }
}

public struct FfiConverterTypeFfiXmtpClient: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiXmtpClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiXmtpClient {
        return FfiXmtpClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiXmtpClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiXmtpClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiXmtpClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFfiXmtpClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiXmtpClient {
    return try FfiConverterTypeFfiXmtpClient.lift(pointer)
}

public func FfiConverterTypeFfiXmtpClient_lower(_ value: FfiXmtpClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiXmtpClient.lower(value)
}

public struct FfiCreateGroupOptions {
    public var permissions: FfiGroupPermissionsOptions?
    public var groupName: String?
    public var groupImageUrlSquare: String?
    public var groupDescription: String?
    public var groupPinnedFrameUrl: String?
    public var customPermissionPolicySet: FfiPermissionPolicySet?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(permissions: FfiGroupPermissionsOptions?, groupName: String?, groupImageUrlSquare: String?, groupDescription: String?, groupPinnedFrameUrl: String?, customPermissionPolicySet: FfiPermissionPolicySet?) {
        self.permissions = permissions
        self.groupName = groupName
        self.groupImageUrlSquare = groupImageUrlSquare
        self.groupDescription = groupDescription
        self.groupPinnedFrameUrl = groupPinnedFrameUrl
        self.customPermissionPolicySet = customPermissionPolicySet
    }
}

extension FfiCreateGroupOptions: Equatable, Hashable {
    public static func == (lhs: FfiCreateGroupOptions, rhs: FfiCreateGroupOptions) -> Bool {
        if lhs.permissions != rhs.permissions {
            return false
        }
        if lhs.groupName != rhs.groupName {
            return false
        }
        if lhs.groupImageUrlSquare != rhs.groupImageUrlSquare {
            return false
        }
        if lhs.groupDescription != rhs.groupDescription {
            return false
        }
        if lhs.groupPinnedFrameUrl != rhs.groupPinnedFrameUrl {
            return false
        }
        if lhs.customPermissionPolicySet != rhs.customPermissionPolicySet {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(permissions)
        hasher.combine(groupName)
        hasher.combine(groupImageUrlSquare)
        hasher.combine(groupDescription)
        hasher.combine(groupPinnedFrameUrl)
        hasher.combine(customPermissionPolicySet)
    }
}

public struct FfiConverterTypeFfiCreateGroupOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiCreateGroupOptions {
        return
            try FfiCreateGroupOptions(
                permissions: FfiConverterOptionTypeFfiGroupPermissionsOptions.read(from: &buf),
                groupName: FfiConverterOptionString.read(from: &buf),
                groupImageUrlSquare: FfiConverterOptionString.read(from: &buf),
                groupDescription: FfiConverterOptionString.read(from: &buf),
                groupPinnedFrameUrl: FfiConverterOptionString.read(from: &buf),
                customPermissionPolicySet: FfiConverterOptionTypeFfiPermissionPolicySet.read(from: &buf)
            )
    }

    public static func write(_ value: FfiCreateGroupOptions, into buf: inout [UInt8]) {
        FfiConverterOptionTypeFfiGroupPermissionsOptions.write(value.permissions, into: &buf)
        FfiConverterOptionString.write(value.groupName, into: &buf)
        FfiConverterOptionString.write(value.groupImageUrlSquare, into: &buf)
        FfiConverterOptionString.write(value.groupDescription, into: &buf)
        FfiConverterOptionString.write(value.groupPinnedFrameUrl, into: &buf)
        FfiConverterOptionTypeFfiPermissionPolicySet.write(value.customPermissionPolicySet, into: &buf)
    }
}

public func FfiConverterTypeFfiCreateGroupOptions_lift(_ buf: RustBuffer) throws -> FfiCreateGroupOptions {
    return try FfiConverterTypeFfiCreateGroupOptions.lift(buf)
}

public func FfiConverterTypeFfiCreateGroupOptions_lower(_ value: FfiCreateGroupOptions) -> RustBuffer {
    return FfiConverterTypeFfiCreateGroupOptions.lower(value)
}

public struct FfiCursor {
    public var digest: Data
    public var senderTimeNs: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(digest: Data, senderTimeNs: UInt64) {
        self.digest = digest
        self.senderTimeNs = senderTimeNs
    }
}

extension FfiCursor: Equatable, Hashable {
    public static func == (lhs: FfiCursor, rhs: FfiCursor) -> Bool {
        if lhs.digest != rhs.digest {
            return false
        }
        if lhs.senderTimeNs != rhs.senderTimeNs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(digest)
        hasher.combine(senderTimeNs)
    }
}

public struct FfiConverterTypeFfiCursor: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiCursor {
        return
            try FfiCursor(
                digest: FfiConverterData.read(from: &buf),
                senderTimeNs: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: FfiCursor, into buf: inout [UInt8]) {
        FfiConverterData.write(value.digest, into: &buf)
        FfiConverterUInt64.write(value.senderTimeNs, into: &buf)
    }
}

public func FfiConverterTypeFfiCursor_lift(_ buf: RustBuffer) throws -> FfiCursor {
    return try FfiConverterTypeFfiCursor.lift(buf)
}

public func FfiConverterTypeFfiCursor_lower(_ value: FfiCursor) -> RustBuffer {
    return FfiConverterTypeFfiCursor.lower(value)
}

public struct FfiEnvelope {
    public var contentTopic: String
    public var timestampNs: UInt64
    public var message: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(contentTopic: String, timestampNs: UInt64, message: Data) {
        self.contentTopic = contentTopic
        self.timestampNs = timestampNs
        self.message = message
    }
}

extension FfiEnvelope: Equatable, Hashable {
    public static func == (lhs: FfiEnvelope, rhs: FfiEnvelope) -> Bool {
        if lhs.contentTopic != rhs.contentTopic {
            return false
        }
        if lhs.timestampNs != rhs.timestampNs {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(contentTopic)
        hasher.combine(timestampNs)
        hasher.combine(message)
    }
}

public struct FfiConverterTypeFfiEnvelope: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiEnvelope {
        return
            try FfiEnvelope(
                contentTopic: FfiConverterString.read(from: &buf),
                timestampNs: FfiConverterUInt64.read(from: &buf),
                message: FfiConverterData.read(from: &buf)
            )
    }

    public static func write(_ value: FfiEnvelope, into buf: inout [UInt8]) {
        FfiConverterString.write(value.contentTopic, into: &buf)
        FfiConverterUInt64.write(value.timestampNs, into: &buf)
        FfiConverterData.write(value.message, into: &buf)
    }
}

public func FfiConverterTypeFfiEnvelope_lift(_ buf: RustBuffer) throws -> FfiEnvelope {
    return try FfiConverterTypeFfiEnvelope.lift(buf)
}

public func FfiConverterTypeFfiEnvelope_lower(_ value: FfiEnvelope) -> RustBuffer {
    return FfiConverterTypeFfiEnvelope.lower(value)
}

public struct FfiGroupMember {
    public var inboxId: String
    public var accountAddresses: [String]
    public var installationIds: [Data]
    public var permissionLevel: FfiPermissionLevel
    public var consentState: FfiConsentState

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(inboxId: String, accountAddresses: [String], installationIds: [Data], permissionLevel: FfiPermissionLevel, consentState: FfiConsentState) {
        self.inboxId = inboxId
        self.accountAddresses = accountAddresses
        self.installationIds = installationIds
        self.permissionLevel = permissionLevel
        self.consentState = consentState
    }
}

extension FfiGroupMember: Equatable, Hashable {
    public static func == (lhs: FfiGroupMember, rhs: FfiGroupMember) -> Bool {
        if lhs.inboxId != rhs.inboxId {
            return false
        }
        if lhs.accountAddresses != rhs.accountAddresses {
            return false
        }
        if lhs.installationIds != rhs.installationIds {
            return false
        }
        if lhs.permissionLevel != rhs.permissionLevel {
            return false
        }
        if lhs.consentState != rhs.consentState {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inboxId)
        hasher.combine(accountAddresses)
        hasher.combine(installationIds)
        hasher.combine(permissionLevel)
        hasher.combine(consentState)
    }
}

public struct FfiConverterTypeFfiGroupMember: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiGroupMember {
        return
            try FfiGroupMember(
                inboxId: FfiConverterString.read(from: &buf),
                accountAddresses: FfiConverterSequenceString.read(from: &buf),
                installationIds: FfiConverterSequenceData.read(from: &buf),
                permissionLevel: FfiConverterTypeFfiPermissionLevel.read(from: &buf),
                consentState: FfiConverterTypeFfiConsentState.read(from: &buf)
            )
    }

    public static func write(_ value: FfiGroupMember, into buf: inout [UInt8]) {
        FfiConverterString.write(value.inboxId, into: &buf)
        FfiConverterSequenceString.write(value.accountAddresses, into: &buf)
        FfiConverterSequenceData.write(value.installationIds, into: &buf)
        FfiConverterTypeFfiPermissionLevel.write(value.permissionLevel, into: &buf)
        FfiConverterTypeFfiConsentState.write(value.consentState, into: &buf)
    }
}

public func FfiConverterTypeFfiGroupMember_lift(_ buf: RustBuffer) throws -> FfiGroupMember {
    return try FfiConverterTypeFfiGroupMember.lift(buf)
}

public func FfiConverterTypeFfiGroupMember_lower(_ value: FfiGroupMember) -> RustBuffer {
    return FfiConverterTypeFfiGroupMember.lower(value)
}

public struct FfiInboxState {
    public var inboxId: String
    public var recoveryAddress: String
    public var installationIds: [Data]
    public var accountAddresses: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(inboxId: String, recoveryAddress: String, installationIds: [Data], accountAddresses: [String]) {
        self.inboxId = inboxId
        self.recoveryAddress = recoveryAddress
        self.installationIds = installationIds
        self.accountAddresses = accountAddresses
    }
}

extension FfiInboxState: Equatable, Hashable {
    public static func == (lhs: FfiInboxState, rhs: FfiInboxState) -> Bool {
        if lhs.inboxId != rhs.inboxId {
            return false
        }
        if lhs.recoveryAddress != rhs.recoveryAddress {
            return false
        }
        if lhs.installationIds != rhs.installationIds {
            return false
        }
        if lhs.accountAddresses != rhs.accountAddresses {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inboxId)
        hasher.combine(recoveryAddress)
        hasher.combine(installationIds)
        hasher.combine(accountAddresses)
    }
}

public struct FfiConverterTypeFfiInboxState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiInboxState {
        return
            try FfiInboxState(
                inboxId: FfiConverterString.read(from: &buf),
                recoveryAddress: FfiConverterString.read(from: &buf),
                installationIds: FfiConverterSequenceData.read(from: &buf),
                accountAddresses: FfiConverterSequenceString.read(from: &buf)
            )
    }

    public static func write(_ value: FfiInboxState, into buf: inout [UInt8]) {
        FfiConverterString.write(value.inboxId, into: &buf)
        FfiConverterString.write(value.recoveryAddress, into: &buf)
        FfiConverterSequenceData.write(value.installationIds, into: &buf)
        FfiConverterSequenceString.write(value.accountAddresses, into: &buf)
    }
}

public func FfiConverterTypeFfiInboxState_lift(_ buf: RustBuffer) throws -> FfiInboxState {
    return try FfiConverterTypeFfiInboxState.lift(buf)
}

public func FfiConverterTypeFfiInboxState_lower(_ value: FfiInboxState) -> RustBuffer {
    return FfiConverterTypeFfiInboxState.lower(value)
}

public struct FfiListConversationsOptions {
    public var createdAfterNs: Int64?
    public var createdBeforeNs: Int64?
    public var limit: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(createdAfterNs: Int64?, createdBeforeNs: Int64?, limit: Int64?) {
        self.createdAfterNs = createdAfterNs
        self.createdBeforeNs = createdBeforeNs
        self.limit = limit
    }
}

extension FfiListConversationsOptions: Equatable, Hashable {
    public static func == (lhs: FfiListConversationsOptions, rhs: FfiListConversationsOptions) -> Bool {
        if lhs.createdAfterNs != rhs.createdAfterNs {
            return false
        }
        if lhs.createdBeforeNs != rhs.createdBeforeNs {
            return false
        }
        if lhs.limit != rhs.limit {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(createdAfterNs)
        hasher.combine(createdBeforeNs)
        hasher.combine(limit)
    }
}

public struct FfiConverterTypeFfiListConversationsOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiListConversationsOptions {
        return
            try FfiListConversationsOptions(
                createdAfterNs: FfiConverterOptionInt64.read(from: &buf),
                createdBeforeNs: FfiConverterOptionInt64.read(from: &buf),
                limit: FfiConverterOptionInt64.read(from: &buf)
            )
    }

    public static func write(_ value: FfiListConversationsOptions, into buf: inout [UInt8]) {
        FfiConverterOptionInt64.write(value.createdAfterNs, into: &buf)
        FfiConverterOptionInt64.write(value.createdBeforeNs, into: &buf)
        FfiConverterOptionInt64.write(value.limit, into: &buf)
    }
}

public func FfiConverterTypeFfiListConversationsOptions_lift(_ buf: RustBuffer) throws -> FfiListConversationsOptions {
    return try FfiConverterTypeFfiListConversationsOptions.lift(buf)
}

public func FfiConverterTypeFfiListConversationsOptions_lower(_ value: FfiListConversationsOptions) -> RustBuffer {
    return FfiConverterTypeFfiListConversationsOptions.lower(value)
}

public struct FfiListMessagesOptions {
    public var sentBeforeNs: Int64?
    public var sentAfterNs: Int64?
    public var limit: Int64?
    public var deliveryStatus: FfiDeliveryStatus?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(sentBeforeNs: Int64?, sentAfterNs: Int64?, limit: Int64?, deliveryStatus: FfiDeliveryStatus?) {
        self.sentBeforeNs = sentBeforeNs
        self.sentAfterNs = sentAfterNs
        self.limit = limit
        self.deliveryStatus = deliveryStatus
    }
}

extension FfiListMessagesOptions: Equatable, Hashable {
    public static func == (lhs: FfiListMessagesOptions, rhs: FfiListMessagesOptions) -> Bool {
        if lhs.sentBeforeNs != rhs.sentBeforeNs {
            return false
        }
        if lhs.sentAfterNs != rhs.sentAfterNs {
            return false
        }
        if lhs.limit != rhs.limit {
            return false
        }
        if lhs.deliveryStatus != rhs.deliveryStatus {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sentBeforeNs)
        hasher.combine(sentAfterNs)
        hasher.combine(limit)
        hasher.combine(deliveryStatus)
    }
}

public struct FfiConverterTypeFfiListMessagesOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiListMessagesOptions {
        return
            try FfiListMessagesOptions(
                sentBeforeNs: FfiConverterOptionInt64.read(from: &buf),
                sentAfterNs: FfiConverterOptionInt64.read(from: &buf),
                limit: FfiConverterOptionInt64.read(from: &buf),
                deliveryStatus: FfiConverterOptionTypeFfiDeliveryStatus.read(from: &buf)
            )
    }

    public static func write(_ value: FfiListMessagesOptions, into buf: inout [UInt8]) {
        FfiConverterOptionInt64.write(value.sentBeforeNs, into: &buf)
        FfiConverterOptionInt64.write(value.sentAfterNs, into: &buf)
        FfiConverterOptionInt64.write(value.limit, into: &buf)
        FfiConverterOptionTypeFfiDeliveryStatus.write(value.deliveryStatus, into: &buf)
    }
}

public func FfiConverterTypeFfiListMessagesOptions_lift(_ buf: RustBuffer) throws -> FfiListMessagesOptions {
    return try FfiConverterTypeFfiListMessagesOptions.lift(buf)
}

public func FfiConverterTypeFfiListMessagesOptions_lower(_ value: FfiListMessagesOptions) -> RustBuffer {
    return FfiConverterTypeFfiListMessagesOptions.lower(value)
}

public struct FfiMessage {
    public var id: Data
    public var sentAtNs: Int64
    public var convoId: Data
    public var senderInboxId: String
    public var content: Data
    public var kind: FfiGroupMessageKind
    public var deliveryStatus: FfiDeliveryStatus

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: Data, sentAtNs: Int64, convoId: Data, senderInboxId: String, content: Data, kind: FfiGroupMessageKind, deliveryStatus: FfiDeliveryStatus) {
        self.id = id
        self.sentAtNs = sentAtNs
        self.convoId = convoId
        self.senderInboxId = senderInboxId
        self.content = content
        self.kind = kind
        self.deliveryStatus = deliveryStatus
    }
}

extension FfiMessage: Equatable, Hashable {
    public static func == (lhs: FfiMessage, rhs: FfiMessage) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.sentAtNs != rhs.sentAtNs {
            return false
        }
        if lhs.convoId != rhs.convoId {
            return false
        }
        if lhs.senderInboxId != rhs.senderInboxId {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        if lhs.kind != rhs.kind {
            return false
        }
        if lhs.deliveryStatus != rhs.deliveryStatus {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(sentAtNs)
        hasher.combine(convoId)
        hasher.combine(senderInboxId)
        hasher.combine(content)
        hasher.combine(kind)
        hasher.combine(deliveryStatus)
    }
}

public struct FfiConverterTypeFfiMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiMessage {
        return
            try FfiMessage(
                id: FfiConverterData.read(from: &buf),
                sentAtNs: FfiConverterInt64.read(from: &buf),
                convoId: FfiConverterData.read(from: &buf),
                senderInboxId: FfiConverterString.read(from: &buf),
                content: FfiConverterData.read(from: &buf),
                kind: FfiConverterTypeFfiGroupMessageKind.read(from: &buf),
                deliveryStatus: FfiConverterTypeFfiDeliveryStatus.read(from: &buf)
            )
    }

    public static func write(_ value: FfiMessage, into buf: inout [UInt8]) {
        FfiConverterData.write(value.id, into: &buf)
        FfiConverterInt64.write(value.sentAtNs, into: &buf)
        FfiConverterData.write(value.convoId, into: &buf)
        FfiConverterString.write(value.senderInboxId, into: &buf)
        FfiConverterData.write(value.content, into: &buf)
        FfiConverterTypeFfiGroupMessageKind.write(value.kind, into: &buf)
        FfiConverterTypeFfiDeliveryStatus.write(value.deliveryStatus, into: &buf)
    }
}

public func FfiConverterTypeFfiMessage_lift(_ buf: RustBuffer) throws -> FfiMessage {
    return try FfiConverterTypeFfiMessage.lift(buf)
}

public func FfiConverterTypeFfiMessage_lower(_ value: FfiMessage) -> RustBuffer {
    return FfiConverterTypeFfiMessage.lower(value)
}

public struct FfiPagingInfo {
    public var limit: UInt32
    public var cursor: FfiCursor?
    public var direction: FfiSortDirection

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(limit: UInt32, cursor: FfiCursor?, direction: FfiSortDirection) {
        self.limit = limit
        self.cursor = cursor
        self.direction = direction
    }
}

extension FfiPagingInfo: Equatable, Hashable {
    public static func == (lhs: FfiPagingInfo, rhs: FfiPagingInfo) -> Bool {
        if lhs.limit != rhs.limit {
            return false
        }
        if lhs.cursor != rhs.cursor {
            return false
        }
        if lhs.direction != rhs.direction {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(limit)
        hasher.combine(cursor)
        hasher.combine(direction)
    }
}

public struct FfiConverterTypeFfiPagingInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiPagingInfo {
        return
            try FfiPagingInfo(
                limit: FfiConverterUInt32.read(from: &buf),
                cursor: FfiConverterOptionTypeFfiCursor.read(from: &buf),
                direction: FfiConverterTypeFfiSortDirection.read(from: &buf)
            )
    }

    public static func write(_ value: FfiPagingInfo, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.limit, into: &buf)
        FfiConverterOptionTypeFfiCursor.write(value.cursor, into: &buf)
        FfiConverterTypeFfiSortDirection.write(value.direction, into: &buf)
    }
}

public func FfiConverterTypeFfiPagingInfo_lift(_ buf: RustBuffer) throws -> FfiPagingInfo {
    return try FfiConverterTypeFfiPagingInfo.lift(buf)
}

public func FfiConverterTypeFfiPagingInfo_lower(_ value: FfiPagingInfo) -> RustBuffer {
    return FfiConverterTypeFfiPagingInfo.lower(value)
}

public struct FfiPermissionPolicySet {
    public var addMemberPolicy: FfiPermissionPolicy
    public var removeMemberPolicy: FfiPermissionPolicy
    public var addAdminPolicy: FfiPermissionPolicy
    public var removeAdminPolicy: FfiPermissionPolicy
    public var updateGroupNamePolicy: FfiPermissionPolicy
    public var updateGroupDescriptionPolicy: FfiPermissionPolicy
    public var updateGroupImageUrlSquarePolicy: FfiPermissionPolicy
    public var updateGroupPinnedFrameUrlPolicy: FfiPermissionPolicy

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(addMemberPolicy: FfiPermissionPolicy, removeMemberPolicy: FfiPermissionPolicy, addAdminPolicy: FfiPermissionPolicy, removeAdminPolicy: FfiPermissionPolicy, updateGroupNamePolicy: FfiPermissionPolicy, updateGroupDescriptionPolicy: FfiPermissionPolicy, updateGroupImageUrlSquarePolicy: FfiPermissionPolicy, updateGroupPinnedFrameUrlPolicy: FfiPermissionPolicy) {
        self.addMemberPolicy = addMemberPolicy
        self.removeMemberPolicy = removeMemberPolicy
        self.addAdminPolicy = addAdminPolicy
        self.removeAdminPolicy = removeAdminPolicy
        self.updateGroupNamePolicy = updateGroupNamePolicy
        self.updateGroupDescriptionPolicy = updateGroupDescriptionPolicy
        self.updateGroupImageUrlSquarePolicy = updateGroupImageUrlSquarePolicy
        self.updateGroupPinnedFrameUrlPolicy = updateGroupPinnedFrameUrlPolicy
    }
}

extension FfiPermissionPolicySet: Equatable, Hashable {
    public static func == (lhs: FfiPermissionPolicySet, rhs: FfiPermissionPolicySet) -> Bool {
        if lhs.addMemberPolicy != rhs.addMemberPolicy {
            return false
        }
        if lhs.removeMemberPolicy != rhs.removeMemberPolicy {
            return false
        }
        if lhs.addAdminPolicy != rhs.addAdminPolicy {
            return false
        }
        if lhs.removeAdminPolicy != rhs.removeAdminPolicy {
            return false
        }
        if lhs.updateGroupNamePolicy != rhs.updateGroupNamePolicy {
            return false
        }
        if lhs.updateGroupDescriptionPolicy != rhs.updateGroupDescriptionPolicy {
            return false
        }
        if lhs.updateGroupImageUrlSquarePolicy != rhs.updateGroupImageUrlSquarePolicy {
            return false
        }
        if lhs.updateGroupPinnedFrameUrlPolicy != rhs.updateGroupPinnedFrameUrlPolicy {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(addMemberPolicy)
        hasher.combine(removeMemberPolicy)
        hasher.combine(addAdminPolicy)
        hasher.combine(removeAdminPolicy)
        hasher.combine(updateGroupNamePolicy)
        hasher.combine(updateGroupDescriptionPolicy)
        hasher.combine(updateGroupImageUrlSquarePolicy)
        hasher.combine(updateGroupPinnedFrameUrlPolicy)
    }
}

public struct FfiConverterTypeFfiPermissionPolicySet: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiPermissionPolicySet {
        return
            try FfiPermissionPolicySet(
                addMemberPolicy: FfiConverterTypeFfiPermissionPolicy.read(from: &buf),
                removeMemberPolicy: FfiConverterTypeFfiPermissionPolicy.read(from: &buf),
                addAdminPolicy: FfiConverterTypeFfiPermissionPolicy.read(from: &buf),
                removeAdminPolicy: FfiConverterTypeFfiPermissionPolicy.read(from: &buf),
                updateGroupNamePolicy: FfiConverterTypeFfiPermissionPolicy.read(from: &buf),
                updateGroupDescriptionPolicy: FfiConverterTypeFfiPermissionPolicy.read(from: &buf),
                updateGroupImageUrlSquarePolicy: FfiConverterTypeFfiPermissionPolicy.read(from: &buf),
                updateGroupPinnedFrameUrlPolicy: FfiConverterTypeFfiPermissionPolicy.read(from: &buf)
            )
    }

    public static func write(_ value: FfiPermissionPolicySet, into buf: inout [UInt8]) {
        FfiConverterTypeFfiPermissionPolicy.write(value.addMemberPolicy, into: &buf)
        FfiConverterTypeFfiPermissionPolicy.write(value.removeMemberPolicy, into: &buf)
        FfiConverterTypeFfiPermissionPolicy.write(value.addAdminPolicy, into: &buf)
        FfiConverterTypeFfiPermissionPolicy.write(value.removeAdminPolicy, into: &buf)
        FfiConverterTypeFfiPermissionPolicy.write(value.updateGroupNamePolicy, into: &buf)
        FfiConverterTypeFfiPermissionPolicy.write(value.updateGroupDescriptionPolicy, into: &buf)
        FfiConverterTypeFfiPermissionPolicy.write(value.updateGroupImageUrlSquarePolicy, into: &buf)
        FfiConverterTypeFfiPermissionPolicy.write(value.updateGroupPinnedFrameUrlPolicy, into: &buf)
    }
}

public func FfiConverterTypeFfiPermissionPolicySet_lift(_ buf: RustBuffer) throws -> FfiPermissionPolicySet {
    return try FfiConverterTypeFfiPermissionPolicySet.lift(buf)
}

public func FfiConverterTypeFfiPermissionPolicySet_lower(_ value: FfiPermissionPolicySet) -> RustBuffer {
    return FfiConverterTypeFfiPermissionPolicySet.lower(value)
}

public struct FfiPublishRequest {
    public var envelopes: [FfiEnvelope]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(envelopes: [FfiEnvelope]) {
        self.envelopes = envelopes
    }
}

extension FfiPublishRequest: Equatable, Hashable {
    public static func == (lhs: FfiPublishRequest, rhs: FfiPublishRequest) -> Bool {
        if lhs.envelopes != rhs.envelopes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(envelopes)
    }
}

public struct FfiConverterTypeFfiPublishRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiPublishRequest {
        return
            try FfiPublishRequest(
                envelopes: FfiConverterSequenceTypeFfiEnvelope.read(from: &buf)
            )
    }

    public static func write(_ value: FfiPublishRequest, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFfiEnvelope.write(value.envelopes, into: &buf)
    }
}

public func FfiConverterTypeFfiPublishRequest_lift(_ buf: RustBuffer) throws -> FfiPublishRequest {
    return try FfiConverterTypeFfiPublishRequest.lift(buf)
}

public func FfiConverterTypeFfiPublishRequest_lower(_ value: FfiPublishRequest) -> RustBuffer {
    return FfiConverterTypeFfiPublishRequest.lower(value)
}

public struct FfiV2BatchQueryRequest {
    public var requests: [FfiV2QueryRequest]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(requests: [FfiV2QueryRequest]) {
        self.requests = requests
    }
}

extension FfiV2BatchQueryRequest: Equatable, Hashable {
    public static func == (lhs: FfiV2BatchQueryRequest, rhs: FfiV2BatchQueryRequest) -> Bool {
        if lhs.requests != rhs.requests {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(requests)
    }
}

public struct FfiConverterTypeFfiV2BatchQueryRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiV2BatchQueryRequest {
        return
            try FfiV2BatchQueryRequest(
                requests: FfiConverterSequenceTypeFfiV2QueryRequest.read(from: &buf)
            )
    }

    public static func write(_ value: FfiV2BatchQueryRequest, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFfiV2QueryRequest.write(value.requests, into: &buf)
    }
}

public func FfiConverterTypeFfiV2BatchQueryRequest_lift(_ buf: RustBuffer) throws -> FfiV2BatchQueryRequest {
    return try FfiConverterTypeFfiV2BatchQueryRequest.lift(buf)
}

public func FfiConverterTypeFfiV2BatchQueryRequest_lower(_ value: FfiV2BatchQueryRequest) -> RustBuffer {
    return FfiConverterTypeFfiV2BatchQueryRequest.lower(value)
}

public struct FfiV2BatchQueryResponse {
    public var responses: [FfiV2QueryResponse]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(responses: [FfiV2QueryResponse]) {
        self.responses = responses
    }
}

extension FfiV2BatchQueryResponse: Equatable, Hashable {
    public static func == (lhs: FfiV2BatchQueryResponse, rhs: FfiV2BatchQueryResponse) -> Bool {
        if lhs.responses != rhs.responses {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(responses)
    }
}

public struct FfiConverterTypeFfiV2BatchQueryResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiV2BatchQueryResponse {
        return
            try FfiV2BatchQueryResponse(
                responses: FfiConverterSequenceTypeFfiV2QueryResponse.read(from: &buf)
            )
    }

    public static func write(_ value: FfiV2BatchQueryResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFfiV2QueryResponse.write(value.responses, into: &buf)
    }
}

public func FfiConverterTypeFfiV2BatchQueryResponse_lift(_ buf: RustBuffer) throws -> FfiV2BatchQueryResponse {
    return try FfiConverterTypeFfiV2BatchQueryResponse.lift(buf)
}

public func FfiConverterTypeFfiV2BatchQueryResponse_lower(_ value: FfiV2BatchQueryResponse) -> RustBuffer {
    return FfiConverterTypeFfiV2BatchQueryResponse.lower(value)
}

public struct FfiV2QueryRequest {
    public var contentTopics: [String]
    public var startTimeNs: UInt64
    public var endTimeNs: UInt64
    public var pagingInfo: FfiPagingInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(contentTopics: [String], startTimeNs: UInt64, endTimeNs: UInt64, pagingInfo: FfiPagingInfo?) {
        self.contentTopics = contentTopics
        self.startTimeNs = startTimeNs
        self.endTimeNs = endTimeNs
        self.pagingInfo = pagingInfo
    }
}

extension FfiV2QueryRequest: Equatable, Hashable {
    public static func == (lhs: FfiV2QueryRequest, rhs: FfiV2QueryRequest) -> Bool {
        if lhs.contentTopics != rhs.contentTopics {
            return false
        }
        if lhs.startTimeNs != rhs.startTimeNs {
            return false
        }
        if lhs.endTimeNs != rhs.endTimeNs {
            return false
        }
        if lhs.pagingInfo != rhs.pagingInfo {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(contentTopics)
        hasher.combine(startTimeNs)
        hasher.combine(endTimeNs)
        hasher.combine(pagingInfo)
    }
}

public struct FfiConverterTypeFfiV2QueryRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiV2QueryRequest {
        return
            try FfiV2QueryRequest(
                contentTopics: FfiConverterSequenceString.read(from: &buf),
                startTimeNs: FfiConverterUInt64.read(from: &buf),
                endTimeNs: FfiConverterUInt64.read(from: &buf),
                pagingInfo: FfiConverterOptionTypeFfiPagingInfo.read(from: &buf)
            )
    }

    public static func write(_ value: FfiV2QueryRequest, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.contentTopics, into: &buf)
        FfiConverterUInt64.write(value.startTimeNs, into: &buf)
        FfiConverterUInt64.write(value.endTimeNs, into: &buf)
        FfiConverterOptionTypeFfiPagingInfo.write(value.pagingInfo, into: &buf)
    }
}

public func FfiConverterTypeFfiV2QueryRequest_lift(_ buf: RustBuffer) throws -> FfiV2QueryRequest {
    return try FfiConverterTypeFfiV2QueryRequest.lift(buf)
}

public func FfiConverterTypeFfiV2QueryRequest_lower(_ value: FfiV2QueryRequest) -> RustBuffer {
    return FfiConverterTypeFfiV2QueryRequest.lower(value)
}

public struct FfiV2QueryResponse {
    public var envelopes: [FfiEnvelope]
    public var pagingInfo: FfiPagingInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(envelopes: [FfiEnvelope], pagingInfo: FfiPagingInfo?) {
        self.envelopes = envelopes
        self.pagingInfo = pagingInfo
    }
}

extension FfiV2QueryResponse: Equatable, Hashable {
    public static func == (lhs: FfiV2QueryResponse, rhs: FfiV2QueryResponse) -> Bool {
        if lhs.envelopes != rhs.envelopes {
            return false
        }
        if lhs.pagingInfo != rhs.pagingInfo {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(envelopes)
        hasher.combine(pagingInfo)
    }
}

public struct FfiConverterTypeFfiV2QueryResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiV2QueryResponse {
        return
            try FfiV2QueryResponse(
                envelopes: FfiConverterSequenceTypeFfiEnvelope.read(from: &buf),
                pagingInfo: FfiConverterOptionTypeFfiPagingInfo.read(from: &buf)
            )
    }

    public static func write(_ value: FfiV2QueryResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFfiEnvelope.write(value.envelopes, into: &buf)
        FfiConverterOptionTypeFfiPagingInfo.write(value.pagingInfo, into: &buf)
    }
}

public func FfiConverterTypeFfiV2QueryResponse_lift(_ buf: RustBuffer) throws -> FfiV2QueryResponse {
    return try FfiConverterTypeFfiV2QueryResponse.lift(buf)
}

public func FfiConverterTypeFfiV2QueryResponse_lower(_ value: FfiV2QueryResponse) -> RustBuffer {
    return FfiConverterTypeFfiV2QueryResponse.lower(value)
}

public struct FfiV2SubscribeRequest {
    public var contentTopics: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(contentTopics: [String]) {
        self.contentTopics = contentTopics
    }
}

extension FfiV2SubscribeRequest: Equatable, Hashable {
    public static func == (lhs: FfiV2SubscribeRequest, rhs: FfiV2SubscribeRequest) -> Bool {
        if lhs.contentTopics != rhs.contentTopics {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(contentTopics)
    }
}

public struct FfiConverterTypeFfiV2SubscribeRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiV2SubscribeRequest {
        return
            try FfiV2SubscribeRequest(
                contentTopics: FfiConverterSequenceString.read(from: &buf)
            )
    }

    public static func write(_ value: FfiV2SubscribeRequest, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.contentTopics, into: &buf)
    }
}

public func FfiConverterTypeFfiV2SubscribeRequest_lift(_ buf: RustBuffer) throws -> FfiV2SubscribeRequest {
    return try FfiConverterTypeFfiV2SubscribeRequest.lift(buf)
}

public func FfiConverterTypeFfiV2SubscribeRequest_lower(_ value: FfiV2SubscribeRequest) -> RustBuffer {
    return FfiConverterTypeFfiV2SubscribeRequest.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiConsentEntityType {
    case groupId
    case inboxId
    case address
}

public struct FfiConverterTypeFfiConsentEntityType: FfiConverterRustBuffer {
    typealias SwiftType = FfiConsentEntityType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConsentEntityType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .groupId

        case 2: return .inboxId

        case 3: return .address

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiConsentEntityType, into buf: inout [UInt8]) {
        switch value {
        case .groupId:
            writeInt(&buf, Int32(1))

        case .inboxId:
            writeInt(&buf, Int32(2))

        case .address:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeFfiConsentEntityType_lift(_ buf: RustBuffer) throws -> FfiConsentEntityType {
    return try FfiConverterTypeFfiConsentEntityType.lift(buf)
}

public func FfiConverterTypeFfiConsentEntityType_lower(_ value: FfiConsentEntityType) -> RustBuffer {
    return FfiConverterTypeFfiConsentEntityType.lower(value)
}

extension FfiConsentEntityType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiConsentState {
    case unknown
    case allowed
    case denied
}

public struct FfiConverterTypeFfiConsentState: FfiConverterRustBuffer {
    typealias SwiftType = FfiConsentState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConsentState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .unknown

        case 2: return .allowed

        case 3: return .denied

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiConsentState, into buf: inout [UInt8]) {
        switch value {
        case .unknown:
            writeInt(&buf, Int32(1))

        case .allowed:
            writeInt(&buf, Int32(2))

        case .denied:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeFfiConsentState_lift(_ buf: RustBuffer) throws -> FfiConsentState {
    return try FfiConverterTypeFfiConsentState.lift(buf)
}

public func FfiConverterTypeFfiConsentState_lower(_ value: FfiConsentState) -> RustBuffer {
    return FfiConverterTypeFfiConsentState.lower(value)
}

extension FfiConsentState: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiDeliveryStatus {
    case unpublished
    case published
    case failed
}

public struct FfiConverterTypeFfiDeliveryStatus: FfiConverterRustBuffer {
    typealias SwiftType = FfiDeliveryStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiDeliveryStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .unpublished

        case 2: return .published

        case 3: return .failed

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiDeliveryStatus, into buf: inout [UInt8]) {
        switch value {
        case .unpublished:
            writeInt(&buf, Int32(1))

        case .published:
            writeInt(&buf, Int32(2))

        case .failed:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeFfiDeliveryStatus_lift(_ buf: RustBuffer) throws -> FfiDeliveryStatus {
    return try FfiConverterTypeFfiDeliveryStatus.lift(buf)
}

public func FfiConverterTypeFfiDeliveryStatus_lower(_ value: FfiDeliveryStatus) -> RustBuffer {
    return FfiConverterTypeFfiDeliveryStatus.lower(value)
}

extension FfiDeliveryStatus: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiGroupMessageKind {
    case application
    case membershipChange
}

public struct FfiConverterTypeFfiGroupMessageKind: FfiConverterRustBuffer {
    typealias SwiftType = FfiGroupMessageKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiGroupMessageKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .application

        case 2: return .membershipChange

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiGroupMessageKind, into buf: inout [UInt8]) {
        switch value {
        case .application:
            writeInt(&buf, Int32(1))

        case .membershipChange:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeFfiGroupMessageKind_lift(_ buf: RustBuffer) throws -> FfiGroupMessageKind {
    return try FfiConverterTypeFfiGroupMessageKind.lift(buf)
}

public func FfiConverterTypeFfiGroupMessageKind_lower(_ value: FfiGroupMessageKind) -> RustBuffer {
    return FfiConverterTypeFfiGroupMessageKind.lower(value)
}

extension FfiGroupMessageKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiGroupPermissionsOptions {
    case allMembers
    case adminOnly
    case customPolicy
}

public struct FfiConverterTypeFfiGroupPermissionsOptions: FfiConverterRustBuffer {
    typealias SwiftType = FfiGroupPermissionsOptions

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiGroupPermissionsOptions {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .allMembers

        case 2: return .adminOnly

        case 3: return .customPolicy

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiGroupPermissionsOptions, into buf: inout [UInt8]) {
        switch value {
        case .allMembers:
            writeInt(&buf, Int32(1))

        case .adminOnly:
            writeInt(&buf, Int32(2))

        case .customPolicy:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeFfiGroupPermissionsOptions_lift(_ buf: RustBuffer) throws -> FfiGroupPermissionsOptions {
    return try FfiConverterTypeFfiGroupPermissionsOptions.lift(buf)
}

public func FfiConverterTypeFfiGroupPermissionsOptions_lower(_ value: FfiGroupPermissionsOptions) -> RustBuffer {
    return FfiConverterTypeFfiGroupPermissionsOptions.lower(value)
}

extension FfiGroupPermissionsOptions: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiMetadataField {
    case groupName
    case description
    case imageUrlSquare
    case pinnedFrameUrl
}

public struct FfiConverterTypeFfiMetadataField: FfiConverterRustBuffer {
    typealias SwiftType = FfiMetadataField

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiMetadataField {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .groupName

        case 2: return .description

        case 3: return .imageUrlSquare

        case 4: return .pinnedFrameUrl

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiMetadataField, into buf: inout [UInt8]) {
        switch value {
        case .groupName:
            writeInt(&buf, Int32(1))

        case .description:
            writeInt(&buf, Int32(2))

        case .imageUrlSquare:
            writeInt(&buf, Int32(3))

        case .pinnedFrameUrl:
            writeInt(&buf, Int32(4))
        }
    }
}

public func FfiConverterTypeFfiMetadataField_lift(_ buf: RustBuffer) throws -> FfiMetadataField {
    return try FfiConverterTypeFfiMetadataField.lift(buf)
}

public func FfiConverterTypeFfiMetadataField_lower(_ value: FfiMetadataField) -> RustBuffer {
    return FfiConverterTypeFfiMetadataField.lower(value)
}

extension FfiMetadataField: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiPermissionLevel {
    case member
    case admin
    case superAdmin
}

public struct FfiConverterTypeFfiPermissionLevel: FfiConverterRustBuffer {
    typealias SwiftType = FfiPermissionLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiPermissionLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .member

        case 2: return .admin

        case 3: return .superAdmin

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiPermissionLevel, into buf: inout [UInt8]) {
        switch value {
        case .member:
            writeInt(&buf, Int32(1))

        case .admin:
            writeInt(&buf, Int32(2))

        case .superAdmin:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeFfiPermissionLevel_lift(_ buf: RustBuffer) throws -> FfiPermissionLevel {
    return try FfiConverterTypeFfiPermissionLevel.lift(buf)
}

public func FfiConverterTypeFfiPermissionLevel_lower(_ value: FfiPermissionLevel) -> RustBuffer {
    return FfiConverterTypeFfiPermissionLevel.lower(value)
}

extension FfiPermissionLevel: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiPermissionPolicy {
    case allow
    case deny
    case admin
    case superAdmin
    case doesNotExist
    case other
}

public struct FfiConverterTypeFfiPermissionPolicy: FfiConverterRustBuffer {
    typealias SwiftType = FfiPermissionPolicy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiPermissionPolicy {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .allow

        case 2: return .deny

        case 3: return .admin

        case 4: return .superAdmin

        case 5: return .doesNotExist

        case 6: return .other

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiPermissionPolicy, into buf: inout [UInt8]) {
        switch value {
        case .allow:
            writeInt(&buf, Int32(1))

        case .deny:
            writeInt(&buf, Int32(2))

        case .admin:
            writeInt(&buf, Int32(3))

        case .superAdmin:
            writeInt(&buf, Int32(4))

        case .doesNotExist:
            writeInt(&buf, Int32(5))

        case .other:
            writeInt(&buf, Int32(6))
        }
    }
}

public func FfiConverterTypeFfiPermissionPolicy_lift(_ buf: RustBuffer) throws -> FfiPermissionPolicy {
    return try FfiConverterTypeFfiPermissionPolicy.lift(buf)
}

public func FfiConverterTypeFfiPermissionPolicy_lower(_ value: FfiPermissionPolicy) -> RustBuffer {
    return FfiConverterTypeFfiPermissionPolicy.lower(value)
}

extension FfiPermissionPolicy: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiPermissionUpdateType {
    case addMember
    case removeMember
    case addAdmin
    case removeAdmin
    case updateMetadata
}

public struct FfiConverterTypeFfiPermissionUpdateType: FfiConverterRustBuffer {
    typealias SwiftType = FfiPermissionUpdateType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiPermissionUpdateType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .addMember

        case 2: return .removeMember

        case 3: return .addAdmin

        case 4: return .removeAdmin

        case 5: return .updateMetadata

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiPermissionUpdateType, into buf: inout [UInt8]) {
        switch value {
        case .addMember:
            writeInt(&buf, Int32(1))

        case .removeMember:
            writeInt(&buf, Int32(2))

        case .addAdmin:
            writeInt(&buf, Int32(3))

        case .removeAdmin:
            writeInt(&buf, Int32(4))

        case .updateMetadata:
            writeInt(&buf, Int32(5))
        }
    }
}

public func FfiConverterTypeFfiPermissionUpdateType_lift(_ buf: RustBuffer) throws -> FfiPermissionUpdateType {
    return try FfiConverterTypeFfiPermissionUpdateType.lift(buf)
}

public func FfiConverterTypeFfiPermissionUpdateType_lower(_ value: FfiPermissionUpdateType) -> RustBuffer {
    return FfiConverterTypeFfiPermissionUpdateType.lower(value)
}

extension FfiPermissionUpdateType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FfiSortDirection {
    case unspecified
    case ascending
    case descending
}

public struct FfiConverterTypeFfiSortDirection: FfiConverterRustBuffer {
    typealias SwiftType = FfiSortDirection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiSortDirection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .unspecified

        case 2: return .ascending

        case 3: return .descending

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiSortDirection, into buf: inout [UInt8]) {
        switch value {
        case .unspecified:
            writeInt(&buf, Int32(1))

        case .ascending:
            writeInt(&buf, Int32(2))

        case .descending:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeFfiSortDirection_lift(_ buf: RustBuffer) throws -> FfiSortDirection {
    return try FfiConverterTypeFfiSortDirection.lift(buf)
}

public func FfiConverterTypeFfiSortDirection_lower(_ value: FfiSortDirection) -> RustBuffer {
    return FfiConverterTypeFfiSortDirection.lower(value)
}

extension FfiSortDirection: Equatable, Hashable {}

public enum GenericError {
    case Client(message: String)

    case ClientBuilder(message: String)

    case Storage(message: String)

    case ApiError(message: String)

    case GroupError(message: String)

    case Signature(message: String)

    case GroupMetadata(message: String)

    case GroupMutablePermissions(message: String)

    case Generic(message: String)

    case SignatureRequestError(message: String)

    case Erc1271SignatureError(message: String)
}

public struct FfiConverterTypeGenericError: FfiConverterRustBuffer {
    typealias SwiftType = GenericError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GenericError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .Client(
                message: FfiConverterString.read(from: &buf)
            )

        case 2: return try .ClientBuilder(
                message: FfiConverterString.read(from: &buf)
            )

        case 3: return try .Storage(
                message: FfiConverterString.read(from: &buf)
            )

        case 4: return try .ApiError(
                message: FfiConverterString.read(from: &buf)
            )

        case 5: return try .GroupError(
                message: FfiConverterString.read(from: &buf)
            )

        case 6: return try .Signature(
                message: FfiConverterString.read(from: &buf)
            )

        case 7: return try .GroupMetadata(
                message: FfiConverterString.read(from: &buf)
            )

        case 8: return try .GroupMutablePermissions(
                message: FfiConverterString.read(from: &buf)
            )

        case 9: return try .Generic(
                message: FfiConverterString.read(from: &buf)
            )

        case 10: return try .SignatureRequestError(
                message: FfiConverterString.read(from: &buf)
            )

        case 11: return try .Erc1271SignatureError(
                message: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GenericError, into buf: inout [UInt8]) {
        switch value {
        case .Client(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(1))
        case .ClientBuilder(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(2))
        case .Storage(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(3))
        case .ApiError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(4))
        case .GroupError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(5))
        case .Signature(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(6))
        case .GroupMetadata(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(7))
        case .GroupMutablePermissions(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(8))
        case .Generic(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(9))
        case .SignatureRequestError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(10))
        case .Erc1271SignatureError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(11))
        }
    }
}

extension GenericError: Equatable, Hashable {}

extension GenericError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

public enum SigningError {
    case Generic(message: String)
}

public struct FfiConverterTypeSigningError: FfiConverterRustBuffer {
    typealias SwiftType = SigningError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SigningError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .Generic(
                message: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SigningError, into buf: inout [UInt8]) {
        switch value {
        case .Generic(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(1))
        }
    }
}

extension SigningError: Equatable, Hashable {}

extension SigningError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

public protocol FfiConversationCallback: AnyObject {
    func onConversation(conversation: FfiGroup)
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceFfiConversationCallback {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceFfiConversationCallback = .init(
        onConversation: { (
            uniffiHandle: UInt64,
            conversation: UnsafeMutableRawPointer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceFfiConversationCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.onConversation(
                    conversation: FfiConverterTypeFfiGroup.lift(conversation)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterCallbackInterfaceFfiConversationCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FfiConversationCallback: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitFfiConversationCallback() {
    uniffi_xmtpv3_fn_init_callback_vtable_fficonversationcallback(&UniffiCallbackInterfaceFfiConversationCallback.vtable)
}

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceFfiConversationCallback {
    fileprivate static var handleMap = UniffiHandleMap<FfiConversationCallback>()
}

extension FfiConverterCallbackInterfaceFfiConversationCallback: FfiConverter {
    typealias SwiftType = FfiConversationCallback
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

public protocol FfiInboxOwner: AnyObject {
    func getAddress() -> String

    func sign(text: String) throws -> Data
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceFfiInboxOwner {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceFfiInboxOwner = .init(
        getAddress: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> String in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceFfiInboxOwner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.getAddress(
                )
            }

            let writeReturn = { uniffiOutReturn.pointee = FfiConverterString.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        sign: { (
            uniffiHandle: UInt64,
            text: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Data in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceFfiInboxOwner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.sign(
                    text: FfiConverterString.lift(text)
                )
            }

            let writeReturn = { uniffiOutReturn.pointee = FfiConverterData.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeSigningError.lower
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterCallbackInterfaceFfiInboxOwner.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FfiInboxOwner: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitFfiInboxOwner() {
    uniffi_xmtpv3_fn_init_callback_vtable_ffiinboxowner(&UniffiCallbackInterfaceFfiInboxOwner.vtable)
}

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceFfiInboxOwner {
    fileprivate static var handleMap = UniffiHandleMap<FfiInboxOwner>()
}

extension FfiConverterCallbackInterfaceFfiInboxOwner: FfiConverter {
    typealias SwiftType = FfiInboxOwner
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

public protocol FfiLogger: AnyObject {
    func log(level: UInt32, levelLabel: String, message: String)
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceFfiLogger {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceFfiLogger = .init(
        log: { (
            uniffiHandle: UInt64,
            level: UInt32,
            levelLabel: RustBuffer,
            message: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceFfiLogger.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.log(
                    level: FfiConverterUInt32.lift(level),
                    levelLabel: FfiConverterString.lift(levelLabel),
                    message: FfiConverterString.lift(message)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterCallbackInterfaceFfiLogger.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FfiLogger: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitFfiLogger() {
    uniffi_xmtpv3_fn_init_callback_vtable_ffilogger(&UniffiCallbackInterfaceFfiLogger.vtable)
}

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceFfiLogger {
    fileprivate static var handleMap = UniffiHandleMap<FfiLogger>()
}

extension FfiConverterCallbackInterfaceFfiLogger: FfiConverter {
    typealias SwiftType = FfiLogger
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

public protocol FfiMessageCallback: AnyObject {
    func onMessage(message: FfiMessage)
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceFfiMessageCallback {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceFfiMessageCallback = .init(
        onMessage: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceFfiMessageCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.onMessage(
                    message: FfiConverterTypeFfiMessage.lift(message)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterCallbackInterfaceFfiMessageCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FfiMessageCallback: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitFfiMessageCallback() {
    uniffi_xmtpv3_fn_init_callback_vtable_ffimessagecallback(&UniffiCallbackInterfaceFfiMessageCallback.vtable)
}

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceFfiMessageCallback {
    fileprivate static var handleMap = UniffiHandleMap<FfiMessageCallback>()
}

extension FfiConverterCallbackInterfaceFfiMessageCallback: FfiConverter {
    typealias SwiftType = FfiMessageCallback
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

public protocol FfiV2SubscriptionCallback: AnyObject {
    func onMessage(message: FfiEnvelope)
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceFfiV2SubscriptionCallback {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceFfiV2SubscriptionCallback = .init(
        onMessage: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceFfiV2SubscriptionCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.onMessage(
                    message: FfiConverterTypeFfiEnvelope.lift(message)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterCallbackInterfaceFfiV2SubscriptionCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FfiV2SubscriptionCallback: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitFfiV2SubscriptionCallback() {
    uniffi_xmtpv3_fn_init_callback_vtable_ffiv2subscriptioncallback(&UniffiCallbackInterfaceFfiV2SubscriptionCallback.vtable)
}

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceFfiV2SubscriptionCallback {
    fileprivate static var handleMap = UniffiHandleMap<FfiV2SubscriptionCallback>()
}

extension FfiConverterCallbackInterfaceFfiV2SubscriptionCallback: FfiConverter {
    typealias SwiftType = FfiV2SubscriptionCallback
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

private struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionData: FfiConverterRustBuffer {
    typealias SwiftType = Data?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeFfiSignatureRequest: FfiConverterRustBuffer {
    typealias SwiftType = FfiSignatureRequest?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiSignatureRequest.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiSignatureRequest.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeFfiCursor: FfiConverterRustBuffer {
    typealias SwiftType = FfiCursor?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiCursor.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiCursor.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeFfiPagingInfo: FfiConverterRustBuffer {
    typealias SwiftType = FfiPagingInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiPagingInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiPagingInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeFfiPermissionPolicySet: FfiConverterRustBuffer {
    typealias SwiftType = FfiPermissionPolicySet?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiPermissionPolicySet.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiPermissionPolicySet.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeFfiDeliveryStatus: FfiConverterRustBuffer {
    typealias SwiftType = FfiDeliveryStatus?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiDeliveryStatus.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiDeliveryStatus.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeFfiGroupPermissionsOptions: FfiConverterRustBuffer {
    typealias SwiftType = FfiGroupPermissionsOptions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiGroupPermissionsOptions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiGroupPermissionsOptions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeFfiMetadataField: FfiConverterRustBuffer {
    typealias SwiftType = FfiMetadataField?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiMetadataField.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiMetadataField.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceData: FfiConverterRustBuffer {
    typealias SwiftType = [Data]

    public static func write(_ value: [Data], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterData.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Data] {
        let len: Int32 = try readInt(&buf)
        var seq = [Data]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterData.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFfiGroup: FfiConverterRustBuffer {
    typealias SwiftType = [FfiGroup]

    public static func write(_ value: [FfiGroup], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiGroup.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiGroup] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiGroup]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFfiGroup.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFfiEnvelope: FfiConverterRustBuffer {
    typealias SwiftType = [FfiEnvelope]

    public static func write(_ value: [FfiEnvelope], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiEnvelope.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiEnvelope] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiEnvelope]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFfiEnvelope.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFfiGroupMember: FfiConverterRustBuffer {
    typealias SwiftType = [FfiGroupMember]

    public static func write(_ value: [FfiGroupMember], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiGroupMember.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiGroupMember] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiGroupMember]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFfiGroupMember.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFfiMessage: FfiConverterRustBuffer {
    typealias SwiftType = [FfiMessage]

    public static func write(_ value: [FfiMessage], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiMessage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiMessage] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiMessage]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFfiMessage.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFfiV2QueryRequest: FfiConverterRustBuffer {
    typealias SwiftType = [FfiV2QueryRequest]

    public static func write(_ value: [FfiV2QueryRequest], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiV2QueryRequest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiV2QueryRequest] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiV2QueryRequest]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFfiV2QueryRequest.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFfiV2QueryResponse: FfiConverterRustBuffer {
    typealias SwiftType = [FfiV2QueryResponse]

    public static func write(_ value: [FfiV2QueryResponse], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiV2QueryResponse.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiV2QueryResponse] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiV2QueryResponse]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFfiV2QueryResponse.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterDictionaryStringBool: FfiConverterRustBuffer {
    public static func write(_ value: [String: Bool], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterBool.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Bool] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Bool]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterBool.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

private let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

private func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> Void,
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> Void,
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
private func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}

/**
 * It returns a new client of the specified `inbox_id`.
 * Note that the `inbox_id` must be either brand new or already associated with the `account_address`.
 * i.e. `inbox_id` cannot be associated with another account address.
 *
 * Prior to calling this function, it's suggested to form `inbox_id`, `account_address`, and `nonce` like below.
 *
 * ```text
 * inbox_id = get_inbox_id_for_address(account_address)
 * nonce = 0
 *
 * // if inbox_id is not associated, we will create new one.
 * if !inbox_id {
 * if !legacy_key { nonce = random_u64() }
 * inbox_id = generate_inbox_id(account_address, nonce)
 * } // Otherwise, we will just use the inbox and ignore the nonce.
 * db_path = $inbox_id-$env
 *
 * xmtp.create_client(account_address, nonce, inbox_id, Option<legacy_signed_private_key_proto>)
 * ```
 */
public func createClient(logger: FfiLogger, host: String, isSecure: Bool, db: String?, encryptionKey: Data?, inboxId: String, accountAddress: String, nonce: UInt64, legacySignedPrivateKeyProto: Data?, historySyncUrl: String?) async throws -> FfiXmtpClient {
    return
        try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_func_create_client(FfiConverterCallbackInterfaceFfiLogger.lower(logger), FfiConverterString.lower(host), FfiConverterBool.lower(isSecure), FfiConverterOptionString.lower(db), FfiConverterOptionData.lower(encryptionKey), FfiConverterString.lower(inboxId), FfiConverterString.lower(accountAddress), FfiConverterUInt64.lower(nonce), FfiConverterOptionData.lower(legacySignedPrivateKeyProto), FfiConverterOptionString.lower(historySyncUrl))
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiXmtpClient.lift,
            errorHandler: FfiConverterTypeGenericError.lift
        )
}

public func createV2Client(host: String, isSecure: Bool) async throws -> FfiV2ApiClient {
    return
        try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_func_create_v2_client(FfiConverterString.lower(host), FfiConverterBool.lower(isSecure))
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiV2ApiClient.lift,
            errorHandler: FfiConverterTypeGenericError.lift
        )
}

public func diffieHellmanK256(privateKeyBytes: Data, publicKeyBytes: Data) throws -> Data {
    return try FfiConverterData.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
        uniffi_xmtpv3_fn_func_diffie_hellman_k256(
            FfiConverterData.lower(privateKeyBytes),
            FfiConverterData.lower(publicKeyBytes), $0
        )
    })
}

public func generateInboxId(accountAddress: String, nonce: UInt64) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_xmtpv3_fn_func_generate_inbox_id(
            FfiConverterString.lower(accountAddress),
            FfiConverterUInt64.lower(nonce), $0
        )
    })
}

public func generatePrivatePreferencesTopicIdentifier(privateKey: Data) throws -> String {
    return try FfiConverterString.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
        uniffi_xmtpv3_fn_func_generate_private_preferences_topic_identifier(
            FfiConverterData.lower(privateKey), $0
        )
    })
}

public func getInboxIdForAddress(logger: FfiLogger, host: String, isSecure: Bool, accountAddress: String) async throws -> String? {
    return
        try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_func_get_inbox_id_for_address(FfiConverterCallbackInterfaceFfiLogger.lower(logger), FfiConverterString.lower(host), FfiConverterBool.lower(isSecure), FfiConverterString.lower(accountAddress))
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeGenericError.lift
        )
}

public func getVersionInfo() -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_xmtpv3_fn_func_get_version_info($0
        )
    })
}

public func keccak256(input: Data) -> Data {
    return try! FfiConverterData.lift(try! rustCall {
        uniffi_xmtpv3_fn_func_keccak256(
            FfiConverterData.lower(input), $0
        )
    })
}

public func publicKeyFromPrivateKeyK256(privateKeyBytes: Data) throws -> Data {
    return try FfiConverterData.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
        uniffi_xmtpv3_fn_func_public_key_from_private_key_k256(
            FfiConverterData.lower(privateKeyBytes), $0
        )
    })
}

public func recoverAddress(signatureBytes: Data, predigestMessage: String) throws -> String {
    return try FfiConverterString.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
        uniffi_xmtpv3_fn_func_recover_address(
            FfiConverterData.lower(signatureBytes),
            FfiConverterString.lower(predigestMessage), $0
        )
    })
}

public func recoverPublicKeyK256Keccak256(message: Data, signature: Data) throws -> Data {
    return try FfiConverterData.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
        uniffi_xmtpv3_fn_func_recover_public_key_k256_keccak256(
            FfiConverterData.lower(message),
            FfiConverterData.lower(signature), $0
        )
    })
}

public func recoverPublicKeyK256Sha256(message: Data, signature: Data) throws -> Data {
    return try FfiConverterData.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
        uniffi_xmtpv3_fn_func_recover_public_key_k256_sha256(
            FfiConverterData.lower(message),
            FfiConverterData.lower(signature), $0
        )
    })
}

public func sha256(input: Data) -> Data {
    return try! FfiConverterData.lift(try! rustCall {
        uniffi_xmtpv3_fn_func_sha256(
            FfiConverterData.lower(input), $0
        )
    })
}

public func userPreferencesDecrypt(publicKey: Data, privateKey: Data, message: Data) throws -> Data {
    return try FfiConverterData.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
        uniffi_xmtpv3_fn_func_user_preferences_decrypt(
            FfiConverterData.lower(publicKey),
            FfiConverterData.lower(privateKey),
            FfiConverterData.lower(message), $0
        )
    })
}

public func userPreferencesEncrypt(publicKey: Data, privateKey: Data, message: Data) throws -> Data {
    return try FfiConverterData.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
        uniffi_xmtpv3_fn_func_user_preferences_encrypt(
            FfiConverterData.lower(publicKey),
            FfiConverterData.lower(privateKey),
            FfiConverterData.lower(message), $0
        )
    })
}

public func verifyK256Sha256(signedBy: Data, message: Data, signature: Data, recoveryId: UInt8) throws -> Bool {
    return try FfiConverterBool.lift(rustCallWithError(FfiConverterTypeGenericError.lift) {
        uniffi_xmtpv3_fn_func_verify_k256_sha256(
            FfiConverterData.lower(signedBy),
            FfiConverterData.lower(message),
            FfiConverterData.lower(signature),
            FfiConverterUInt8.lower(recoveryId), $0
        )
    })
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}

// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_xmtpv3_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if uniffi_xmtpv3_checksum_func_create_client() != 6255 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_create_v2_client() != 48060 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_diffie_hellman_k256() != 37475 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_generate_inbox_id() != 2184 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_generate_private_preferences_topic_identifier() != 59124 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_get_inbox_id_for_address() != 36898 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_get_version_info() != 29277 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_keccak256() != 61901 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_public_key_from_private_key_k256() != 22921 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_recover_address() != 48606 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_recover_public_key_k256_keccak256() != 45215 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_recover_public_key_k256_sha256() != 42303 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_sha256() != 32492 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_user_preferences_decrypt() != 43766 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_user_preferences_encrypt() != 184 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_verify_k256_sha256() != 25521 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_fficonversations_create_group() != 62996 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_fficonversations_list() != 10804 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_fficonversations_process_streamed_welcome_message() != 15283 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_fficonversations_stream() != 3079 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_fficonversations_stream_all_messages() != 13204 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_fficonversations_sync() != 9054 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_fficonversations_sync_all_groups() != 3433 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_add_admin() != 4600 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_add_members() != 27666 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_add_members_by_inbox_id() != 23290 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_add_super_admin() != 40681 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_added_by_inbox_id() != 37220 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_admin_list() != 51010 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_consent_state() != 11630 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_created_at_ns() != 4894 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_find_messages() != 14930 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_group_description() != 37045 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_group_image_url_square() != 16754 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_group_metadata() != 13139 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_group_name() != 61525 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_group_permissions() != 15980 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_group_pinned_frame_url() != 29388 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_id() != 36764 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_is_active() != 33848 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_is_admin() != 26672 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_is_super_admin() != 61614 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_list_members() != 61034 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_process_streamed_group_message() != 19069 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_publish_messages() != 52808 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_remove_admin() != 57094 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_remove_members() != 24336 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_remove_members_by_inbox_id() != 45424 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_remove_super_admin() != 35336 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_send() != 37701 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_send_optimistic() != 13872 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_stream() != 34669 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_super_admin_list() != 5323 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_sync() != 24219 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_update_consent_state() != 48124 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_update_group_description() != 34006 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_update_group_image_url_square() != 18878 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_update_group_name() != 550 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_update_group_pinned_frame_url() != 37434 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_update_permission_policy() != 51936 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroupmetadata_conversation_type() != 30827 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroupmetadata_creator_inbox_id() != 26872 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigrouppermissions_policy_set() != 24928 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigrouppermissions_policy_type() != 56975 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffisignaturerequest_add_ecdsa_signature() != 8706 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffisignaturerequest_add_scw_signature() != 23994 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffisignaturerequest_is_ready() != 65051 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffisignaturerequest_missing_address_signatures() != 34688 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffisignaturerequest_signature_text() != 60472 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffistreamcloser_end() != 11040 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffistreamcloser_end_and_wait() != 1181 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffistreamcloser_is_closed() != 62423 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffiv2apiclient_batch_query() != 26551 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffiv2apiclient_publish() != 3309 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffiv2apiclient_query() != 58821 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffiv2apiclient_set_app_version() != 28472 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffiv2apiclient_subscribe() != 48530 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffiv2subscription_end() != 38721 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffiv2subscription_is_closed() != 4358 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffiv2subscription_update() != 24211 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffixmtpclient_add_wallet() != 23786 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffixmtpclient_apply_signature_request() != 32172 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffixmtpclient_can_message() != 53502 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffixmtpclient_conversations() != 47463 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffixmtpclient_db_reconnect() != 6707 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffixmtpclient_find_inbox_id() != 59020 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffixmtpclient_get_consent_state() != 58208 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffixmtpclient_get_latest_inbox_state() != 3165 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffixmtpclient_group() != 64533 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffixmtpclient_inbox_id() != 25128 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffixmtpclient_inbox_state() != 7826 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffixmtpclient_installation_id() != 37173 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffixmtpclient_message() != 26932 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffixmtpclient_register_identity() != 42003 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffixmtpclient_release_db_connection() != 11067 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffixmtpclient_request_history_sync() != 22295 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffixmtpclient_revoke_all_other_installations() != 36450 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffixmtpclient_revoke_wallet() != 12211 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffixmtpclient_set_consent_state() != 36178 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffixmtpclient_signature_request() != 18270 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffiinboxowner_get_address() != 2205 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffiinboxowner_sign() != 30268 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffilogger_log() != 56011 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_fficonversationcallback_on_conversation() != 42 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffimessagecallback_on_message() != 5286 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffiv2subscriptioncallback_on_message() != 30049 {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitFfiConversationCallback()
    uniffiCallbackInitFfiInboxOwner()
    uniffiCallbackInitFfiLogger()
    uniffiCallbackInitFfiMessageCallback()
    uniffiCallbackInitFfiV2SubscriptionCallback()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all
