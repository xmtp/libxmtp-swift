// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(xmtpv3FFI)
    import xmtpv3FFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_xmtpv3_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_xmtpv3_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_PANIC: Int8 = 2
private let CALL_CANCELLED: Int8 = 3

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T
) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
    case CALL_SUCCESS:
        return

    case CALL_ERROR:
        if let errorHandler = errorHandler {
            throw try errorHandler(callStatus.errorBuf)
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.unexpectedRustCallError
        }

    case CALL_PANIC:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    case CALL_CANCELLED:
        throw CancellationError()

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.

private struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

private struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return try Data(readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

public protocol FfiConversationsProtocol {
    func createGroup(accountAddresses: [String]) async throws -> FfiGroup
    func list(opts: FfiListConversationsOptions) async throws -> [FfiGroup]
    func stream(callback: FfiConversationCallback) async throws -> FfiStreamCloser
    func sync() async throws
}

public class FfiConversations: FfiConversationsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_xmtpv3_fn_free_fficonversations(pointer, $0) }
    }

    public func createGroup(accountAddresses: [String]) async throws -> FfiGroup {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_create_group(
                    self.pointer,
                    FfiConverterSequenceString.lower(accountAddresses)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiGroup.lift,
            errorHandler: FfiConverterTypeGenericError.lift
        )
    }

    public func list(opts: FfiListConversationsOptions) async throws -> [FfiGroup] {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_list(
                    self.pointer,
                    FfiConverterTypeFfiListConversationsOptions.lower(opts)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeFfiGroup.lift,
            errorHandler: FfiConverterTypeGenericError.lift
        )
    }

    public func stream(callback: FfiConversationCallback) async throws -> FfiStreamCloser {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_stream(
                    self.pointer,
                    FfiConverterCallbackInterfaceFfiConversationCallback.lower(callback)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiStreamCloser.lift,
            errorHandler: FfiConverterTypeGenericError.lift
        )
    }

    public func sync() async throws {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_fficonversations_sync(
                    self.pointer
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError.lift
        )
    }
}

public struct FfiConverterTypeFfiConversations: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiConversations

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiConversations {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiConversations, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConversations {
        return FfiConversations(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiConversations) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeFfiConversations_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiConversations {
    return try FfiConverterTypeFfiConversations.lift(pointer)
}

public func FfiConverterTypeFfiConversations_lower(_ value: FfiConversations) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiConversations.lower(value)
}

public protocol FfiGroupProtocol {
    func addMembers(accountAddresses: [String]) async throws
    func createdAtNs() -> Int64
    func findMessages(opts: FfiListMessagesOptions) throws -> [FfiMessage]
    func id() -> Data
    func isActive() throws -> Bool
    func listMembers() throws -> [FfiGroupMember]
    func removeMembers(accountAddresses: [String]) async throws
    func send(contentBytes: Data) async throws
    func stream(messageCallback: FfiMessageCallback) async throws -> FfiStreamCloser
    func sync() async throws
}

public class FfiGroup: FfiGroupProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_xmtpv3_fn_free_ffigroup(pointer, $0) }
    }

    public func addMembers(accountAddresses: [String]) async throws {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffigroup_add_members(
                    self.pointer,
                    FfiConverterSequenceString.lower(accountAddresses)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError.lift
        )
    }

    public func createdAtNs() -> Int64 {
        return try! FfiConverterInt64.lift(
            try!
                rustCall {
                    uniffi_xmtpv3_fn_method_ffigroup_created_at_ns(self.pointer, $0)
                }
        )
    }

    public func findMessages(opts: FfiListMessagesOptions) throws -> [FfiMessage] {
        return try FfiConverterSequenceTypeFfiMessage.lift(
            rustCallWithError(FfiConverterTypeGenericError.lift) {
                uniffi_xmtpv3_fn_method_ffigroup_find_messages(self.pointer,
                                                               FfiConverterTypeFfiListMessagesOptions.lower(opts), $0)
            }
        )
    }

    public func id() -> Data {
        return try! FfiConverterData.lift(
            try!
                rustCall {
                    uniffi_xmtpv3_fn_method_ffigroup_id(self.pointer, $0)
                }
        )
    }

    public func isActive() throws -> Bool {
        return try FfiConverterBool.lift(
            rustCallWithError(FfiConverterTypeGenericError.lift) {
                uniffi_xmtpv3_fn_method_ffigroup_is_active(self.pointer, $0)
            }
        )
    }

    public func listMembers() throws -> [FfiGroupMember] {
        return try FfiConverterSequenceTypeFfiGroupMember.lift(
            rustCallWithError(FfiConverterTypeGenericError.lift) {
                uniffi_xmtpv3_fn_method_ffigroup_list_members(self.pointer, $0)
            }
        )
    }

    public func removeMembers(accountAddresses: [String]) async throws {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffigroup_remove_members(
                    self.pointer,
                    FfiConverterSequenceString.lower(accountAddresses)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError.lift
        )
    }

    public func send(contentBytes: Data) async throws {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffigroup_send(
                    self.pointer,
                    FfiConverterData.lower(contentBytes)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError.lift
        )
    }

    public func stream(messageCallback: FfiMessageCallback) async throws -> FfiStreamCloser {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffigroup_stream(
                    self.pointer,
                    FfiConverterCallbackInterfaceFfiMessageCallback.lower(messageCallback)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiStreamCloser.lift,
            errorHandler: FfiConverterTypeGenericError.lift
        )
    }

    public func sync() async throws {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffigroup_sync(
                    self.pointer
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError.lift
        )
    }
}

public struct FfiConverterTypeFfiGroup: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiGroup

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiGroup {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiGroup, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiGroup {
        return FfiGroup(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiGroup) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeFfiGroup_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiGroup {
    return try FfiConverterTypeFfiGroup.lift(pointer)
}

public func FfiConverterTypeFfiGroup_lower(_ value: FfiGroup) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiGroup.lower(value)
}

public protocol FfiStreamCloserProtocol {
    func end()
    func isClosed() -> Bool
}

public class FfiStreamCloser: FfiStreamCloserProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_xmtpv3_fn_free_ffistreamcloser(pointer, $0) }
    }

    public func end() {
        try!
            rustCall {
                uniffi_xmtpv3_fn_method_ffistreamcloser_end(self.pointer, $0)
            }
    }

    public func isClosed() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_xmtpv3_fn_method_ffistreamcloser_is_closed(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeFfiStreamCloser: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiStreamCloser

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiStreamCloser {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiStreamCloser, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiStreamCloser {
        return FfiStreamCloser(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiStreamCloser) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeFfiStreamCloser_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiStreamCloser {
    return try FfiConverterTypeFfiStreamCloser.lift(pointer)
}

public func FfiConverterTypeFfiStreamCloser_lower(_ value: FfiStreamCloser) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiStreamCloser.lower(value)
}

public protocol FfiV2ApiClientProtocol {
    func batchQuery(req: FfiV2BatchQueryRequest) async throws -> FfiV2BatchQueryResponse
    func publish(request: FfiPublishRequest, authToken: String) async throws
    func query(request: FfiV2QueryRequest) async throws -> FfiV2QueryResponse
    func setAppVersion(version: String)
    func subscribe(request: FfiV2SubscribeRequest) async throws -> FfiV2Subscription
}

public class FfiV2ApiClient: FfiV2ApiClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_xmtpv3_fn_free_ffiv2apiclient(pointer, $0) }
    }

    public func batchQuery(req: FfiV2BatchQueryRequest) async throws -> FfiV2BatchQueryResponse {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffiv2apiclient_batch_query(
                    self.pointer,
                    FfiConverterTypeFfiV2BatchQueryRequest.lower(req)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFfiV2BatchQueryResponse.lift,
            errorHandler: FfiConverterTypeGenericError.lift
        )
    }

    public func publish(request: FfiPublishRequest, authToken: String) async throws {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffiv2apiclient_publish(
                    self.pointer,
                    FfiConverterTypeFfiPublishRequest.lower(request),
                    FfiConverterString.lower(authToken)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError.lift
        )
    }

    public func query(request: FfiV2QueryRequest) async throws -> FfiV2QueryResponse {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffiv2apiclient_query(
                    self.pointer,
                    FfiConverterTypeFfiV2QueryRequest.lower(request)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFfiV2QueryResponse.lift,
            errorHandler: FfiConverterTypeGenericError.lift
        )
    }

    public func setAppVersion(version: String) {
        try!
            rustCall {
                uniffi_xmtpv3_fn_method_ffiv2apiclient_set_app_version(self.pointer,
                                                                       FfiConverterString.lower(version), $0)
            }
    }

    public func subscribe(request: FfiV2SubscribeRequest) async throws -> FfiV2Subscription {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffiv2apiclient_subscribe(
                    self.pointer,
                    FfiConverterTypeFfiV2SubscribeRequest.lower(request)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
            completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
            freeFunc: ffi_xmtpv3_rust_future_free_pointer,
            liftFunc: FfiConverterTypeFfiV2Subscription.lift,
            errorHandler: FfiConverterTypeGenericError.lift
        )
    }
}

public struct FfiConverterTypeFfiV2ApiClient: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiV2ApiClient

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiV2ApiClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiV2ApiClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiV2ApiClient {
        return FfiV2ApiClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiV2ApiClient) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeFfiV2ApiClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiV2ApiClient {
    return try FfiConverterTypeFfiV2ApiClient.lift(pointer)
}

public func FfiConverterTypeFfiV2ApiClient_lower(_ value: FfiV2ApiClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiV2ApiClient.lower(value)
}

public protocol FfiV2SubscriptionProtocol {
    func end() async
    func next() async throws -> FfiEnvelope
    func update(req: FfiV2SubscribeRequest) async throws
}

public class FfiV2Subscription: FfiV2SubscriptionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_xmtpv3_fn_free_ffiv2subscription(pointer, $0) }
    }

    public func end() async {
        return try! await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffiv2subscription_end(
                    self.pointer
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
        )
    }

    public func next() async throws -> FfiEnvelope {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffiv2subscription_next(
                    self.pointer
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFfiEnvelope.lift,
            errorHandler: FfiConverterTypeGenericError.lift
        )
    }

    public func update(req: FfiV2SubscribeRequest) async throws {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffiv2subscription_update(
                    self.pointer,
                    FfiConverterTypeFfiV2SubscribeRequest.lower(req)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError.lift
        )
    }
}

public struct FfiConverterTypeFfiV2Subscription: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiV2Subscription

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiV2Subscription {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiV2Subscription, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiV2Subscription {
        return FfiV2Subscription(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiV2Subscription) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeFfiV2Subscription_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiV2Subscription {
    return try FfiConverterTypeFfiV2Subscription.lift(pointer)
}

public func FfiConverterTypeFfiV2Subscription_lower(_ value: FfiV2Subscription) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiV2Subscription.lower(value)
}

public protocol FfiXmtpClientProtocol {
    func accountAddress() -> String
    func canMessage(accountAddresses: [String]) async throws -> [Bool]
    func conversations() -> FfiConversations
    func registerIdentity(recoverableWalletSignature: Data?) async throws
    func textToSign() -> String?
}

public class FfiXmtpClient: FfiXmtpClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_xmtpv3_fn_free_ffixmtpclient(pointer, $0) }
    }

    public func accountAddress() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_xmtpv3_fn_method_ffixmtpclient_account_address(self.pointer, $0)
                }
        )
    }

    public func canMessage(accountAddresses: [String]) async throws -> [Bool] {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_can_message(
                    self.pointer,
                    FfiConverterSequenceString.lower(accountAddresses)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_rust_buffer,
            completeFunc: ffi_xmtpv3_rust_future_complete_rust_buffer,
            freeFunc: ffi_xmtpv3_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceBool.lift,
            errorHandler: FfiConverterTypeGenericError.lift
        )
    }

    public func conversations() -> FfiConversations {
        return try! FfiConverterTypeFfiConversations.lift(
            try!
                rustCall {
                    uniffi_xmtpv3_fn_method_ffixmtpclient_conversations(self.pointer, $0)
                }
        )
    }

    public func registerIdentity(recoverableWalletSignature: Data?) async throws {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_xmtpv3_fn_method_ffixmtpclient_register_identity(
                    self.pointer,
                    FfiConverterOptionData.lower(recoverableWalletSignature)
                )
            },
            pollFunc: ffi_xmtpv3_rust_future_poll_void,
            completeFunc: ffi_xmtpv3_rust_future_complete_void,
            freeFunc: ffi_xmtpv3_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeGenericError.lift
        )
    }

    public func textToSign() -> String? {
        return try! FfiConverterOptionString.lift(
            try!
                rustCall {
                    uniffi_xmtpv3_fn_method_ffixmtpclient_text_to_sign(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeFfiXmtpClient: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiXmtpClient

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiXmtpClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiXmtpClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiXmtpClient {
        return FfiXmtpClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiXmtpClient) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeFfiXmtpClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiXmtpClient {
    return try FfiConverterTypeFfiXmtpClient.lift(pointer)
}

public func FfiConverterTypeFfiXmtpClient_lower(_ value: FfiXmtpClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiXmtpClient.lower(value)
}

public struct FfiCursor {
    public var digest: Data
    public var senderTimeNs: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(digest: Data, senderTimeNs: UInt64) {
        self.digest = digest
        self.senderTimeNs = senderTimeNs
    }
}

extension FfiCursor: Equatable, Hashable {
    public static func == (lhs: FfiCursor, rhs: FfiCursor) -> Bool {
        if lhs.digest != rhs.digest {
            return false
        }
        if lhs.senderTimeNs != rhs.senderTimeNs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(digest)
        hasher.combine(senderTimeNs)
    }
}

public struct FfiConverterTypeFfiCursor: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiCursor {
        return try FfiCursor(
            digest: FfiConverterData.read(from: &buf),
            senderTimeNs: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiCursor, into buf: inout [UInt8]) {
        FfiConverterData.write(value.digest, into: &buf)
        FfiConverterUInt64.write(value.senderTimeNs, into: &buf)
    }
}

public func FfiConverterTypeFfiCursor_lift(_ buf: RustBuffer) throws -> FfiCursor {
    return try FfiConverterTypeFfiCursor.lift(buf)
}

public func FfiConverterTypeFfiCursor_lower(_ value: FfiCursor) -> RustBuffer {
    return FfiConverterTypeFfiCursor.lower(value)
}

public struct FfiEnvelope {
    public var contentTopic: String
    public var timestampNs: UInt64
    public var message: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(contentTopic: String, timestampNs: UInt64, message: Data) {
        self.contentTopic = contentTopic
        self.timestampNs = timestampNs
        self.message = message
    }
}

extension FfiEnvelope: Equatable, Hashable {
    public static func == (lhs: FfiEnvelope, rhs: FfiEnvelope) -> Bool {
        if lhs.contentTopic != rhs.contentTopic {
            return false
        }
        if lhs.timestampNs != rhs.timestampNs {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(contentTopic)
        hasher.combine(timestampNs)
        hasher.combine(message)
    }
}

public struct FfiConverterTypeFfiEnvelope: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiEnvelope {
        return try FfiEnvelope(
            contentTopic: FfiConverterString.read(from: &buf),
            timestampNs: FfiConverterUInt64.read(from: &buf),
            message: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: FfiEnvelope, into buf: inout [UInt8]) {
        FfiConverterString.write(value.contentTopic, into: &buf)
        FfiConverterUInt64.write(value.timestampNs, into: &buf)
        FfiConverterData.write(value.message, into: &buf)
    }
}

public func FfiConverterTypeFfiEnvelope_lift(_ buf: RustBuffer) throws -> FfiEnvelope {
    return try FfiConverterTypeFfiEnvelope.lift(buf)
}

public func FfiConverterTypeFfiEnvelope_lower(_ value: FfiEnvelope) -> RustBuffer {
    return FfiConverterTypeFfiEnvelope.lower(value)
}

public struct FfiGroupMember {
    public var accountAddress: String
    public var installationIds: [Data]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(accountAddress: String, installationIds: [Data]) {
        self.accountAddress = accountAddress
        self.installationIds = installationIds
    }
}

extension FfiGroupMember: Equatable, Hashable {
    public static func == (lhs: FfiGroupMember, rhs: FfiGroupMember) -> Bool {
        if lhs.accountAddress != rhs.accountAddress {
            return false
        }
        if lhs.installationIds != rhs.installationIds {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accountAddress)
        hasher.combine(installationIds)
    }
}

public struct FfiConverterTypeFfiGroupMember: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiGroupMember {
        return try FfiGroupMember(
            accountAddress: FfiConverterString.read(from: &buf),
            installationIds: FfiConverterSequenceData.read(from: &buf)
        )
    }

    public static func write(_ value: FfiGroupMember, into buf: inout [UInt8]) {
        FfiConverterString.write(value.accountAddress, into: &buf)
        FfiConverterSequenceData.write(value.installationIds, into: &buf)
    }
}

public func FfiConverterTypeFfiGroupMember_lift(_ buf: RustBuffer) throws -> FfiGroupMember {
    return try FfiConverterTypeFfiGroupMember.lift(buf)
}

public func FfiConverterTypeFfiGroupMember_lower(_ value: FfiGroupMember) -> RustBuffer {
    return FfiConverterTypeFfiGroupMember.lower(value)
}

public struct FfiListConversationsOptions {
    public var createdAfterNs: Int64?
    public var createdBeforeNs: Int64?
    public var limit: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(createdAfterNs: Int64?, createdBeforeNs: Int64?, limit: Int64?) {
        self.createdAfterNs = createdAfterNs
        self.createdBeforeNs = createdBeforeNs
        self.limit = limit
    }
}

extension FfiListConversationsOptions: Equatable, Hashable {
    public static func == (lhs: FfiListConversationsOptions, rhs: FfiListConversationsOptions) -> Bool {
        if lhs.createdAfterNs != rhs.createdAfterNs {
            return false
        }
        if lhs.createdBeforeNs != rhs.createdBeforeNs {
            return false
        }
        if lhs.limit != rhs.limit {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(createdAfterNs)
        hasher.combine(createdBeforeNs)
        hasher.combine(limit)
    }
}

public struct FfiConverterTypeFfiListConversationsOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiListConversationsOptions {
        return try FfiListConversationsOptions(
            createdAfterNs: FfiConverterOptionInt64.read(from: &buf),
            createdBeforeNs: FfiConverterOptionInt64.read(from: &buf),
            limit: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiListConversationsOptions, into buf: inout [UInt8]) {
        FfiConverterOptionInt64.write(value.createdAfterNs, into: &buf)
        FfiConverterOptionInt64.write(value.createdBeforeNs, into: &buf)
        FfiConverterOptionInt64.write(value.limit, into: &buf)
    }
}

public func FfiConverterTypeFfiListConversationsOptions_lift(_ buf: RustBuffer) throws -> FfiListConversationsOptions {
    return try FfiConverterTypeFfiListConversationsOptions.lift(buf)
}

public func FfiConverterTypeFfiListConversationsOptions_lower(_ value: FfiListConversationsOptions) -> RustBuffer {
    return FfiConverterTypeFfiListConversationsOptions.lower(value)
}

public struct FfiListMessagesOptions {
    public var sentBeforeNs: Int64?
    public var sentAfterNs: Int64?
    public var limit: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(sentBeforeNs: Int64?, sentAfterNs: Int64?, limit: Int64?) {
        self.sentBeforeNs = sentBeforeNs
        self.sentAfterNs = sentAfterNs
        self.limit = limit
    }
}

extension FfiListMessagesOptions: Equatable, Hashable {
    public static func == (lhs: FfiListMessagesOptions, rhs: FfiListMessagesOptions) -> Bool {
        if lhs.sentBeforeNs != rhs.sentBeforeNs {
            return false
        }
        if lhs.sentAfterNs != rhs.sentAfterNs {
            return false
        }
        if lhs.limit != rhs.limit {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sentBeforeNs)
        hasher.combine(sentAfterNs)
        hasher.combine(limit)
    }
}

public struct FfiConverterTypeFfiListMessagesOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiListMessagesOptions {
        return try FfiListMessagesOptions(
            sentBeforeNs: FfiConverterOptionInt64.read(from: &buf),
            sentAfterNs: FfiConverterOptionInt64.read(from: &buf),
            limit: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiListMessagesOptions, into buf: inout [UInt8]) {
        FfiConverterOptionInt64.write(value.sentBeforeNs, into: &buf)
        FfiConverterOptionInt64.write(value.sentAfterNs, into: &buf)
        FfiConverterOptionInt64.write(value.limit, into: &buf)
    }
}

public func FfiConverterTypeFfiListMessagesOptions_lift(_ buf: RustBuffer) throws -> FfiListMessagesOptions {
    return try FfiConverterTypeFfiListMessagesOptions.lift(buf)
}

public func FfiConverterTypeFfiListMessagesOptions_lower(_ value: FfiListMessagesOptions) -> RustBuffer {
    return FfiConverterTypeFfiListMessagesOptions.lower(value)
}

public struct FfiMessage {
    public var id: Data
    public var sentAtNs: Int64
    public var convoId: Data
    public var addrFrom: String
    public var content: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: Data, sentAtNs: Int64, convoId: Data, addrFrom: String, content: Data) {
        self.id = id
        self.sentAtNs = sentAtNs
        self.convoId = convoId
        self.addrFrom = addrFrom
        self.content = content
    }
}

extension FfiMessage: Equatable, Hashable {
    public static func == (lhs: FfiMessage, rhs: FfiMessage) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.sentAtNs != rhs.sentAtNs {
            return false
        }
        if lhs.convoId != rhs.convoId {
            return false
        }
        if lhs.addrFrom != rhs.addrFrom {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(sentAtNs)
        hasher.combine(convoId)
        hasher.combine(addrFrom)
        hasher.combine(content)
    }
}

public struct FfiConverterTypeFfiMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiMessage {
        return try FfiMessage(
            id: FfiConverterData.read(from: &buf),
            sentAtNs: FfiConverterInt64.read(from: &buf),
            convoId: FfiConverterData.read(from: &buf),
            addrFrom: FfiConverterString.read(from: &buf),
            content: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: FfiMessage, into buf: inout [UInt8]) {
        FfiConverterData.write(value.id, into: &buf)
        FfiConverterInt64.write(value.sentAtNs, into: &buf)
        FfiConverterData.write(value.convoId, into: &buf)
        FfiConverterString.write(value.addrFrom, into: &buf)
        FfiConverterData.write(value.content, into: &buf)
    }
}

public func FfiConverterTypeFfiMessage_lift(_ buf: RustBuffer) throws -> FfiMessage {
    return try FfiConverterTypeFfiMessage.lift(buf)
}

public func FfiConverterTypeFfiMessage_lower(_ value: FfiMessage) -> RustBuffer {
    return FfiConverterTypeFfiMessage.lower(value)
}

public struct FfiPagingInfo {
    public var limit: UInt32
    public var cursor: FfiCursor?
    public var direction: FfiSortDirection

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(limit: UInt32, cursor: FfiCursor?, direction: FfiSortDirection) {
        self.limit = limit
        self.cursor = cursor
        self.direction = direction
    }
}

extension FfiPagingInfo: Equatable, Hashable {
    public static func == (lhs: FfiPagingInfo, rhs: FfiPagingInfo) -> Bool {
        if lhs.limit != rhs.limit {
            return false
        }
        if lhs.cursor != rhs.cursor {
            return false
        }
        if lhs.direction != rhs.direction {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(limit)
        hasher.combine(cursor)
        hasher.combine(direction)
    }
}

public struct FfiConverterTypeFfiPagingInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiPagingInfo {
        return try FfiPagingInfo(
            limit: FfiConverterUInt32.read(from: &buf),
            cursor: FfiConverterOptionTypeFfiCursor.read(from: &buf),
            direction: FfiConverterTypeFfiSortDirection.read(from: &buf)
        )
    }

    public static func write(_ value: FfiPagingInfo, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.limit, into: &buf)
        FfiConverterOptionTypeFfiCursor.write(value.cursor, into: &buf)
        FfiConverterTypeFfiSortDirection.write(value.direction, into: &buf)
    }
}

public func FfiConverterTypeFfiPagingInfo_lift(_ buf: RustBuffer) throws -> FfiPagingInfo {
    return try FfiConverterTypeFfiPagingInfo.lift(buf)
}

public func FfiConverterTypeFfiPagingInfo_lower(_ value: FfiPagingInfo) -> RustBuffer {
    return FfiConverterTypeFfiPagingInfo.lower(value)
}

public struct FfiPublishRequest {
    public var envelopes: [FfiEnvelope]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(envelopes: [FfiEnvelope]) {
        self.envelopes = envelopes
    }
}

extension FfiPublishRequest: Equatable, Hashable {
    public static func == (lhs: FfiPublishRequest, rhs: FfiPublishRequest) -> Bool {
        if lhs.envelopes != rhs.envelopes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(envelopes)
    }
}

public struct FfiConverterTypeFfiPublishRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiPublishRequest {
        return try FfiPublishRequest(
            envelopes: FfiConverterSequenceTypeFfiEnvelope.read(from: &buf)
        )
    }

    public static func write(_ value: FfiPublishRequest, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFfiEnvelope.write(value.envelopes, into: &buf)
    }
}

public func FfiConverterTypeFfiPublishRequest_lift(_ buf: RustBuffer) throws -> FfiPublishRequest {
    return try FfiConverterTypeFfiPublishRequest.lift(buf)
}

public func FfiConverterTypeFfiPublishRequest_lower(_ value: FfiPublishRequest) -> RustBuffer {
    return FfiConverterTypeFfiPublishRequest.lower(value)
}

public struct FfiV2BatchQueryRequest {
    public var requests: [FfiV2QueryRequest]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(requests: [FfiV2QueryRequest]) {
        self.requests = requests
    }
}

extension FfiV2BatchQueryRequest: Equatable, Hashable {
    public static func == (lhs: FfiV2BatchQueryRequest, rhs: FfiV2BatchQueryRequest) -> Bool {
        if lhs.requests != rhs.requests {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(requests)
    }
}

public struct FfiConverterTypeFfiV2BatchQueryRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiV2BatchQueryRequest {
        return try FfiV2BatchQueryRequest(
            requests: FfiConverterSequenceTypeFfiV2QueryRequest.read(from: &buf)
        )
    }

    public static func write(_ value: FfiV2BatchQueryRequest, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFfiV2QueryRequest.write(value.requests, into: &buf)
    }
}

public func FfiConverterTypeFfiV2BatchQueryRequest_lift(_ buf: RustBuffer) throws -> FfiV2BatchQueryRequest {
    return try FfiConverterTypeFfiV2BatchQueryRequest.lift(buf)
}

public func FfiConverterTypeFfiV2BatchQueryRequest_lower(_ value: FfiV2BatchQueryRequest) -> RustBuffer {
    return FfiConverterTypeFfiV2BatchQueryRequest.lower(value)
}

public struct FfiV2BatchQueryResponse {
    public var responses: [FfiV2QueryResponse]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(responses: [FfiV2QueryResponse]) {
        self.responses = responses
    }
}

extension FfiV2BatchQueryResponse: Equatable, Hashable {
    public static func == (lhs: FfiV2BatchQueryResponse, rhs: FfiV2BatchQueryResponse) -> Bool {
        if lhs.responses != rhs.responses {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(responses)
    }
}

public struct FfiConverterTypeFfiV2BatchQueryResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiV2BatchQueryResponse {
        return try FfiV2BatchQueryResponse(
            responses: FfiConverterSequenceTypeFfiV2QueryResponse.read(from: &buf)
        )
    }

    public static func write(_ value: FfiV2BatchQueryResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFfiV2QueryResponse.write(value.responses, into: &buf)
    }
}

public func FfiConverterTypeFfiV2BatchQueryResponse_lift(_ buf: RustBuffer) throws -> FfiV2BatchQueryResponse {
    return try FfiConverterTypeFfiV2BatchQueryResponse.lift(buf)
}

public func FfiConverterTypeFfiV2BatchQueryResponse_lower(_ value: FfiV2BatchQueryResponse) -> RustBuffer {
    return FfiConverterTypeFfiV2BatchQueryResponse.lower(value)
}

public struct FfiV2QueryRequest {
    public var contentTopics: [String]
    public var startTimeNs: UInt64
    public var endTimeNs: UInt64
    public var pagingInfo: FfiPagingInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(contentTopics: [String], startTimeNs: UInt64, endTimeNs: UInt64, pagingInfo: FfiPagingInfo?) {
        self.contentTopics = contentTopics
        self.startTimeNs = startTimeNs
        self.endTimeNs = endTimeNs
        self.pagingInfo = pagingInfo
    }
}

extension FfiV2QueryRequest: Equatable, Hashable {
    public static func == (lhs: FfiV2QueryRequest, rhs: FfiV2QueryRequest) -> Bool {
        if lhs.contentTopics != rhs.contentTopics {
            return false
        }
        if lhs.startTimeNs != rhs.startTimeNs {
            return false
        }
        if lhs.endTimeNs != rhs.endTimeNs {
            return false
        }
        if lhs.pagingInfo != rhs.pagingInfo {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(contentTopics)
        hasher.combine(startTimeNs)
        hasher.combine(endTimeNs)
        hasher.combine(pagingInfo)
    }
}

public struct FfiConverterTypeFfiV2QueryRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiV2QueryRequest {
        return try FfiV2QueryRequest(
            contentTopics: FfiConverterSequenceString.read(from: &buf),
            startTimeNs: FfiConverterUInt64.read(from: &buf),
            endTimeNs: FfiConverterUInt64.read(from: &buf),
            pagingInfo: FfiConverterOptionTypeFfiPagingInfo.read(from: &buf)
        )
    }

    public static func write(_ value: FfiV2QueryRequest, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.contentTopics, into: &buf)
        FfiConverterUInt64.write(value.startTimeNs, into: &buf)
        FfiConverterUInt64.write(value.endTimeNs, into: &buf)
        FfiConverterOptionTypeFfiPagingInfo.write(value.pagingInfo, into: &buf)
    }
}

public func FfiConverterTypeFfiV2QueryRequest_lift(_ buf: RustBuffer) throws -> FfiV2QueryRequest {
    return try FfiConverterTypeFfiV2QueryRequest.lift(buf)
}

public func FfiConverterTypeFfiV2QueryRequest_lower(_ value: FfiV2QueryRequest) -> RustBuffer {
    return FfiConverterTypeFfiV2QueryRequest.lower(value)
}

public struct FfiV2QueryResponse {
    public var envelopes: [FfiEnvelope]
    public var pagingInfo: FfiPagingInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(envelopes: [FfiEnvelope], pagingInfo: FfiPagingInfo?) {
        self.envelopes = envelopes
        self.pagingInfo = pagingInfo
    }
}

extension FfiV2QueryResponse: Equatable, Hashable {
    public static func == (lhs: FfiV2QueryResponse, rhs: FfiV2QueryResponse) -> Bool {
        if lhs.envelopes != rhs.envelopes {
            return false
        }
        if lhs.pagingInfo != rhs.pagingInfo {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(envelopes)
        hasher.combine(pagingInfo)
    }
}

public struct FfiConverterTypeFfiV2QueryResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiV2QueryResponse {
        return try FfiV2QueryResponse(
            envelopes: FfiConverterSequenceTypeFfiEnvelope.read(from: &buf),
            pagingInfo: FfiConverterOptionTypeFfiPagingInfo.read(from: &buf)
        )
    }

    public static func write(_ value: FfiV2QueryResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFfiEnvelope.write(value.envelopes, into: &buf)
        FfiConverterOptionTypeFfiPagingInfo.write(value.pagingInfo, into: &buf)
    }
}

public func FfiConverterTypeFfiV2QueryResponse_lift(_ buf: RustBuffer) throws -> FfiV2QueryResponse {
    return try FfiConverterTypeFfiV2QueryResponse.lift(buf)
}

public func FfiConverterTypeFfiV2QueryResponse_lower(_ value: FfiV2QueryResponse) -> RustBuffer {
    return FfiConverterTypeFfiV2QueryResponse.lower(value)
}

public struct FfiV2SubscribeRequest {
    public var contentTopics: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(contentTopics: [String]) {
        self.contentTopics = contentTopics
    }
}

extension FfiV2SubscribeRequest: Equatable, Hashable {
    public static func == (lhs: FfiV2SubscribeRequest, rhs: FfiV2SubscribeRequest) -> Bool {
        if lhs.contentTopics != rhs.contentTopics {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(contentTopics)
    }
}

public struct FfiConverterTypeFfiV2SubscribeRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiV2SubscribeRequest {
        return try FfiV2SubscribeRequest(
            contentTopics: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiV2SubscribeRequest, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.contentTopics, into: &buf)
    }
}

public func FfiConverterTypeFfiV2SubscribeRequest_lift(_ buf: RustBuffer) throws -> FfiV2SubscribeRequest {
    return try FfiConverterTypeFfiV2SubscribeRequest.lift(buf)
}

public func FfiConverterTypeFfiV2SubscribeRequest_lower(_ value: FfiV2SubscribeRequest) -> RustBuffer {
    return FfiConverterTypeFfiV2SubscribeRequest.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum FfiSortDirection {
    case unspecified
    case ascending
    case descending
}

public struct FfiConverterTypeFfiSortDirection: FfiConverterRustBuffer {
    typealias SwiftType = FfiSortDirection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiSortDirection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .unspecified

        case 2: return .ascending

        case 3: return .descending

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FfiSortDirection, into buf: inout [UInt8]) {
        switch value {
        case .unspecified:
            writeInt(&buf, Int32(1))

        case .ascending:
            writeInt(&buf, Int32(2))

        case .descending:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeFfiSortDirection_lift(_ buf: RustBuffer) throws -> FfiSortDirection {
    return try FfiConverterTypeFfiSortDirection.lift(buf)
}

public func FfiConverterTypeFfiSortDirection_lower(_ value: FfiSortDirection) -> RustBuffer {
    return FfiConverterTypeFfiSortDirection.lower(value)
}

extension FfiSortDirection: Equatable, Hashable {}

public enum GenericError {
    // Simple error enums only carry a message
    case Client(message: String)

    // Simple error enums only carry a message
    case ClientBuilder(message: String)

    // Simple error enums only carry a message
    case Storage(message: String)

    // Simple error enums only carry a message
    case ApiError(message: String)

    // Simple error enums only carry a message
    case GroupError(message: String)

    // Simple error enums only carry a message
    case Signature(message: String)

    // Simple error enums only carry a message
    case Generic(message: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeGenericError.lift(error)
    }
}

public struct FfiConverterTypeGenericError: FfiConverterRustBuffer {
    typealias SwiftType = GenericError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GenericError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .Client(
                message: FfiConverterString.read(from: &buf)
            )

        case 2: return try .ClientBuilder(
                message: FfiConverterString.read(from: &buf)
            )

        case 3: return try .Storage(
                message: FfiConverterString.read(from: &buf)
            )

        case 4: return try .ApiError(
                message: FfiConverterString.read(from: &buf)
            )

        case 5: return try .GroupError(
                message: FfiConverterString.read(from: &buf)
            )

        case 6: return try .Signature(
                message: FfiConverterString.read(from: &buf)
            )

        case 7: return try .Generic(
                message: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GenericError, into buf: inout [UInt8]) {
        switch value {
        case .Client(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(1))
        case .ClientBuilder(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(2))
        case .Storage(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(3))
        case .ApiError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(4))
        case .GroupError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(5))
        case .Signature(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(6))
        case .Generic(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(7))
        }
    }
}

extension GenericError: Equatable, Hashable {}

extension GenericError: Error {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LegacyIdentitySource {
    case none
    case `static`
    case network
    case keyGenerator
}

public struct FfiConverterTypeLegacyIdentitySource: FfiConverterRustBuffer {
    typealias SwiftType = LegacyIdentitySource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegacyIdentitySource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .none

        case 2: return .static

        case 3: return .network

        case 4: return .keyGenerator

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LegacyIdentitySource, into buf: inout [UInt8]) {
        switch value {
        case .none:
            writeInt(&buf, Int32(1))

        case .static:
            writeInt(&buf, Int32(2))

        case .network:
            writeInt(&buf, Int32(3))

        case .keyGenerator:
            writeInt(&buf, Int32(4))
        }
    }
}

public func FfiConverterTypeLegacyIdentitySource_lift(_ buf: RustBuffer) throws -> LegacyIdentitySource {
    return try FfiConverterTypeLegacyIdentitySource.lift(buf)
}

public func FfiConverterTypeLegacyIdentitySource_lower(_ value: LegacyIdentitySource) -> RustBuffer {
    return FfiConverterTypeLegacyIdentitySource.lower(value)
}

extension LegacyIdentitySource: Equatable, Hashable {}

public enum SigningError {
    // Simple error enums only carry a message
    case Generic(message: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeSigningError.lift(error)
    }
}

public struct FfiConverterTypeSigningError: FfiConverterRustBuffer {
    typealias SwiftType = SigningError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SigningError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .Generic(
                message: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SigningError, into buf: inout [UInt8]) {
        switch value {
        case .Generic(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(1))
        }
    }
}

extension SigningError: Equatable, Hashable {}

extension SigningError: Error {}

private extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        lock()
        defer { self.unlock() }
        return try f()
    }
}

private typealias UniFFICallbackHandle = UInt64
private class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 0
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Declaration and FfiConverters for FfiConversationCallback Callback Interface

public protocol FfiConversationCallback: AnyObject {
    func onConversation(conversation: FfiGroup)
}

// The ForeignCallback that is passed to Rust.
private let foreignCallbackCallbackInterfaceFfiConversationCallback: ForeignCallback = { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in

    func invokeOnConversation(_ swiftCallbackInterface: FfiConversationCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onConversation(
                conversation: FfiConverterTypeFfiGroup.read(from: &reader)
            )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    switch method {
    case IDX_CALLBACK_FREE:
        FfiConverterCallbackInterfaceFfiConversationCallback.drop(handle: handle)
        // Sucessful return
        // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
        return UNIFFI_CALLBACK_SUCCESS
    case 1:
        let cb: FfiConversationCallback
        do {
            cb = try FfiConverterCallbackInterfaceFfiConversationCallback.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("FfiConversationCallback: Invalid handle")
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }
        do {
            return try invokeOnConversation(cb, argsData, argsLen, out_buf)
        } catch {
            out_buf.pointee = FfiConverterString.lower(String(describing: error))
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }

    // This should never happen, because an out of bounds method index won't
    // ever be used. Once we can catch errors, we should return an InternalError.
    // https://github.com/mozilla/uniffi-rs/issues/351
    default:
        // An unexpected error happened.
        // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
        return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceFfiConversationCallback {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_xmtpv3_fn_init_callback_fficonversationcallback(foreignCallbackCallbackInterfaceFfiConversationCallback, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<FfiConversationCallback>()
}

extension FfiConverterCallbackInterfaceFfiConversationCallback: FfiConverter {
    typealias SwiftType = FfiConversationCallback
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized()
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized()
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized()
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized()
        writeInt(&buf, lower(v))
    }
}

// Declaration and FfiConverters for FfiInboxOwner Callback Interface

public protocol FfiInboxOwner: AnyObject {
    func getAddress() -> String
    func sign(text: String) throws -> Data
}

// The ForeignCallback that is passed to Rust.
private let foreignCallbackCallbackInterfaceFfiInboxOwner: ForeignCallback = { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in

    func invokeGetAddress(_ swiftCallbackInterface: FfiInboxOwner, _: UnsafePointer<UInt8>, _: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            let result = swiftCallbackInterface.getAddress(
            )
            var writer = [UInt8]()
            FfiConverterString.write(result, into: &writer)
            out_buf.pointee = RustBuffer(bytes: writer)
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeSign(_ swiftCallbackInterface: FfiInboxOwner, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            let result = try swiftCallbackInterface.sign(
                text: FfiConverterString.read(from: &reader)
            )
            var writer = [UInt8]()
            FfiConverterData.write(result, into: &writer)
            out_buf.pointee = RustBuffer(bytes: writer)
            return UNIFFI_CALLBACK_SUCCESS
        }
        do {
            return try makeCall()
        } catch let error as SigningError {
            out_buf.pointee = FfiConverterTypeSigningError.lower(error)
            return UNIFFI_CALLBACK_ERROR
        }
    }

    switch method {
    case IDX_CALLBACK_FREE:
        FfiConverterCallbackInterfaceFfiInboxOwner.drop(handle: handle)
        // Sucessful return
        // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
        return UNIFFI_CALLBACK_SUCCESS
    case 1:
        let cb: FfiInboxOwner
        do {
            cb = try FfiConverterCallbackInterfaceFfiInboxOwner.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("FfiInboxOwner: Invalid handle")
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }
        do {
            return try invokeGetAddress(cb, argsData, argsLen, out_buf)
        } catch {
            out_buf.pointee = FfiConverterString.lower(String(describing: error))
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }
    case 2:
        let cb: FfiInboxOwner
        do {
            cb = try FfiConverterCallbackInterfaceFfiInboxOwner.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("FfiInboxOwner: Invalid handle")
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }
        do {
            return try invokeSign(cb, argsData, argsLen, out_buf)
        } catch {
            out_buf.pointee = FfiConverterString.lower(String(describing: error))
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }

    // This should never happen, because an out of bounds method index won't
    // ever be used. Once we can catch errors, we should return an InternalError.
    // https://github.com/mozilla/uniffi-rs/issues/351
    default:
        // An unexpected error happened.
        // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
        return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceFfiInboxOwner {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_xmtpv3_fn_init_callback_ffiinboxowner(foreignCallbackCallbackInterfaceFfiInboxOwner, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<FfiInboxOwner>()
}

extension FfiConverterCallbackInterfaceFfiInboxOwner: FfiConverter {
    typealias SwiftType = FfiInboxOwner
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized()
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized()
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized()
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized()
        writeInt(&buf, lower(v))
    }
}

// Declaration and FfiConverters for FfiLogger Callback Interface

public protocol FfiLogger: AnyObject {
    func log(level: UInt32, levelLabel: String, message: String)
}

// The ForeignCallback that is passed to Rust.
private let foreignCallbackCallbackInterfaceFfiLogger: ForeignCallback = { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in

    func invokeLog(_ swiftCallbackInterface: FfiLogger, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.log(
                level: FfiConverterUInt32.read(from: &reader),
                levelLabel: FfiConverterString.read(from: &reader),
                message: FfiConverterString.read(from: &reader)
            )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    switch method {
    case IDX_CALLBACK_FREE:
        FfiConverterCallbackInterfaceFfiLogger.drop(handle: handle)
        // Sucessful return
        // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
        return UNIFFI_CALLBACK_SUCCESS
    case 1:
        let cb: FfiLogger
        do {
            cb = try FfiConverterCallbackInterfaceFfiLogger.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("FfiLogger: Invalid handle")
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }
        do {
            return try invokeLog(cb, argsData, argsLen, out_buf)
        } catch {
            out_buf.pointee = FfiConverterString.lower(String(describing: error))
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }

    // This should never happen, because an out of bounds method index won't
    // ever be used. Once we can catch errors, we should return an InternalError.
    // https://github.com/mozilla/uniffi-rs/issues/351
    default:
        // An unexpected error happened.
        // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
        return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceFfiLogger {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_xmtpv3_fn_init_callback_ffilogger(foreignCallbackCallbackInterfaceFfiLogger, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<FfiLogger>()
}

extension FfiConverterCallbackInterfaceFfiLogger: FfiConverter {
    typealias SwiftType = FfiLogger
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized()
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized()
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized()
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized()
        writeInt(&buf, lower(v))
    }
}

// Declaration and FfiConverters for FfiMessageCallback Callback Interface

public protocol FfiMessageCallback: AnyObject {
    func onMessage(message: FfiMessage)
}

// The ForeignCallback that is passed to Rust.
private let foreignCallbackCallbackInterfaceFfiMessageCallback: ForeignCallback = { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in

    func invokeOnMessage(_ swiftCallbackInterface: FfiMessageCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onMessage(
                message: FfiConverterTypeFfiMessage.read(from: &reader)
            )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    switch method {
    case IDX_CALLBACK_FREE:
        FfiConverterCallbackInterfaceFfiMessageCallback.drop(handle: handle)
        // Sucessful return
        // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
        return UNIFFI_CALLBACK_SUCCESS
    case 1:
        let cb: FfiMessageCallback
        do {
            cb = try FfiConverterCallbackInterfaceFfiMessageCallback.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("FfiMessageCallback: Invalid handle")
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }
        do {
            return try invokeOnMessage(cb, argsData, argsLen, out_buf)
        } catch {
            out_buf.pointee = FfiConverterString.lower(String(describing: error))
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }

    // This should never happen, because an out of bounds method index won't
    // ever be used. Once we can catch errors, we should return an InternalError.
    // https://github.com/mozilla/uniffi-rs/issues/351
    default:
        // An unexpected error happened.
        // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
        return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
private enum FfiConverterCallbackInterfaceFfiMessageCallback {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_xmtpv3_fn_init_callback_ffimessagecallback(foreignCallbackCallbackInterfaceFfiMessageCallback, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<FfiMessageCallback>()
}

extension FfiConverterCallbackInterfaceFfiMessageCallback: FfiConverter {
    typealias SwiftType = FfiMessageCallback
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized()
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized()
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized()
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized()
        writeInt(&buf, lower(v))
    }
}

private struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionData: FfiConverterRustBuffer {
    typealias SwiftType = Data?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeFfiCursor: FfiConverterRustBuffer {
    typealias SwiftType = FfiCursor?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiCursor.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiCursor.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeFfiPagingInfo: FfiConverterRustBuffer {
    typealias SwiftType = FfiPagingInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiPagingInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiPagingInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterSequenceBool: FfiConverterRustBuffer {
    typealias SwiftType = [Bool]

    public static func write(_ value: [Bool], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterBool.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bool] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bool]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterBool.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceData: FfiConverterRustBuffer {
    typealias SwiftType = [Data]

    public static func write(_ value: [Data], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterData.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Data] {
        let len: Int32 = try readInt(&buf)
        var seq = [Data]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterData.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFfiGroup: FfiConverterRustBuffer {
    typealias SwiftType = [FfiGroup]

    public static func write(_ value: [FfiGroup], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiGroup.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiGroup] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiGroup]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFfiGroup.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFfiEnvelope: FfiConverterRustBuffer {
    typealias SwiftType = [FfiEnvelope]

    public static func write(_ value: [FfiEnvelope], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiEnvelope.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiEnvelope] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiEnvelope]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFfiEnvelope.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFfiGroupMember: FfiConverterRustBuffer {
    typealias SwiftType = [FfiGroupMember]

    public static func write(_ value: [FfiGroupMember], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiGroupMember.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiGroupMember] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiGroupMember]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFfiGroupMember.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFfiMessage: FfiConverterRustBuffer {
    typealias SwiftType = [FfiMessage]

    public static func write(_ value: [FfiMessage], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiMessage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiMessage] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiMessage]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFfiMessage.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFfiV2QueryRequest: FfiConverterRustBuffer {
    typealias SwiftType = [FfiV2QueryRequest]

    public static func write(_ value: [FfiV2QueryRequest], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiV2QueryRequest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiV2QueryRequest] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiV2QueryRequest]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFfiV2QueryRequest.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFfiV2QueryResponse: FfiConverterRustBuffer {
    typealias SwiftType = [FfiV2QueryResponse]

    public static func write(_ value: [FfiV2QueryResponse], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiV2QueryResponse.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiV2QueryResponse] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiV2QueryResponse]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFfiV2QueryResponse.read(from: &buf))
        }
        return seq
    }
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

private func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UnsafeMutableRawPointer,
    pollFunc: (UnsafeMutableRawPointer, UnsafeMutableRawPointer) -> Void,
    completeFunc: (UnsafeMutableRawPointer, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UnsafeMutableRawPointer) -> Void,
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(rustFuture, ContinuationHolder($0).toOpaque())
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
private func uniffiFutureContinuationCallback(ptr: UnsafeMutableRawPointer, pollResult: Int8) {
    ContinuationHolder.fromOpaque(ptr).resume(pollResult)
}

// Wraps UnsafeContinuation in a class so that we can use reference counting when passing it across
// the FFI
private class ContinuationHolder {
    let continuation: UnsafeContinuation<Int8, Never>

    init(_ continuation: UnsafeContinuation<Int8, Never>) {
        self.continuation = continuation
    }

    func resume(_ pollResult: Int8) {
        continuation.resume(returning: pollResult)
    }

    func toOpaque() -> UnsafeMutableRawPointer {
        return Unmanaged<ContinuationHolder>.passRetained(self).toOpaque()
    }

    static func fromOpaque(_ ptr: UnsafeRawPointer) -> ContinuationHolder {
        return Unmanaged<ContinuationHolder>.fromOpaque(ptr).takeRetainedValue()
    }
}

private func uniffiInitContinuationCallback() {
    ffi_xmtpv3_rust_future_continuation_callback_set(uniffiFutureContinuationCallback)
}

public func createClient(logger: FfiLogger, host: String, isSecure: Bool, db: String?, encryptionKey: Data?, accountAddress: String, legacyIdentitySource: LegacyIdentitySource, legacySignedPrivateKeyProto: Data?) async throws -> FfiXmtpClient {
    return try await uniffiRustCallAsync(
        rustFutureFunc: {
            uniffi_xmtpv3_fn_func_create_client(
                FfiConverterCallbackInterfaceFfiLogger.lower(logger),
                FfiConverterString.lower(host),
                FfiConverterBool.lower(isSecure),
                FfiConverterOptionString.lower(db),
                FfiConverterOptionData.lower(encryptionKey),
                FfiConverterString.lower(accountAddress),
                FfiConverterTypeLegacyIdentitySource.lower(legacyIdentitySource),
                FfiConverterOptionData.lower(legacySignedPrivateKeyProto)
            )
        },
        pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
        completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
        freeFunc: ffi_xmtpv3_rust_future_free_pointer,
        liftFunc: FfiConverterTypeFfiXmtpClient.lift,
        errorHandler: FfiConverterTypeGenericError.lift
    )
}

public func createV2Client(host: String, isSecure: Bool) async throws -> FfiV2ApiClient {
    return try await uniffiRustCallAsync(
        rustFutureFunc: {
            uniffi_xmtpv3_fn_func_create_v2_client(
                FfiConverterString.lower(host),
                FfiConverterBool.lower(isSecure)
            )
        },
        pollFunc: ffi_xmtpv3_rust_future_poll_pointer,
        completeFunc: ffi_xmtpv3_rust_future_complete_pointer,
        freeFunc: ffi_xmtpv3_rust_future_free_pointer,
        liftFunc: FfiConverterTypeFfiV2ApiClient.lift,
        errorHandler: FfiConverterTypeGenericError.lift
    )
}

public func diffieHellmanK256(privateKeyBytes: Data, publicKeyBytes: Data) throws -> Data {
    return try FfiConverterData.lift(
        rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_func_diffie_hellman_k256(
                FfiConverterData.lower(privateKeyBytes),
                FfiConverterData.lower(publicKeyBytes), $0
            )
        }
    )
}

public func generatePrivatePreferencesTopicIdentifier(privateKey: Data) throws -> String {
    return try FfiConverterString.lift(
        rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_func_generate_private_preferences_topic_identifier(
                FfiConverterData.lower(privateKey), $0
            )
        }
    )
}

public func getVersionInfo() -> String {
    return try! FfiConverterString.lift(
        try! rustCall {
            uniffi_xmtpv3_fn_func_get_version_info($0)
        }
    )
}

public func keccak256(input: Data) -> Data {
    return try! FfiConverterData.lift(
        try! rustCall {
            uniffi_xmtpv3_fn_func_keccak256(
                FfiConverterData.lower(input), $0
            )
        }
    )
}

public func publicKeyFromPrivateKeyK256(privateKeyBytes: Data) throws -> Data {
    return try FfiConverterData.lift(
        rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_func_public_key_from_private_key_k256(
                FfiConverterData.lower(privateKeyBytes), $0
            )
        }
    )
}

public func recoverAddress(signatureBytes: Data, predigestMessage: String) throws -> String {
    return try FfiConverterString.lift(
        rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_func_recover_address(
                FfiConverterData.lower(signatureBytes),
                FfiConverterString.lower(predigestMessage), $0
            )
        }
    )
}

public func recoverPublicKeyK256Keccak256(message: Data, signature: Data) throws -> Data {
    return try FfiConverterData.lift(
        rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_func_recover_public_key_k256_keccak256(
                FfiConverterData.lower(message),
                FfiConverterData.lower(signature), $0
            )
        }
    )
}

public func recoverPublicKeyK256Sha256(message: Data, signature: Data) throws -> Data {
    return try FfiConverterData.lift(
        rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_func_recover_public_key_k256_sha256(
                FfiConverterData.lower(message),
                FfiConverterData.lower(signature), $0
            )
        }
    )
}

public func sha256(input: Data) -> Data {
    return try! FfiConverterData.lift(
        try! rustCall {
            uniffi_xmtpv3_fn_func_sha256(
                FfiConverterData.lower(input), $0
            )
        }
    )
}

public func userPreferencesDecrypt(publicKey: Data, privateKey: Data, message: Data) throws -> Data {
    return try FfiConverterData.lift(
        rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_func_user_preferences_decrypt(
                FfiConverterData.lower(publicKey),
                FfiConverterData.lower(privateKey),
                FfiConverterData.lower(message), $0
            )
        }
    )
}

public func userPreferencesEncrypt(publicKey: Data, privateKey: Data, message: Data) throws -> Data {
    return try FfiConverterData.lift(
        rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_func_user_preferences_encrypt(
                FfiConverterData.lower(publicKey),
                FfiConverterData.lower(privateKey),
                FfiConverterData.lower(message), $0
            )
        }
    )
}

public func verifyK256Sha256(signedBy: Data, message: Data, signature: Data, recoveryId: UInt8) throws -> Bool {
    return try FfiConverterBool.lift(
        rustCallWithError(FfiConverterTypeGenericError.lift) {
            uniffi_xmtpv3_fn_func_verify_k256_sha256(
                FfiConverterData.lower(signedBy),
                FfiConverterData.lower(message),
                FfiConverterData.lower(signature),
                FfiConverterUInt8.lower(recoveryId), $0
            )
        }
    )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}

// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 24
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_xmtpv3_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if uniffi_xmtpv3_checksum_func_create_client() != 20422 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_create_v2_client() != 49516 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_diffie_hellman_k256() != 23225 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_generate_private_preferences_topic_identifier() != 5952 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_get_version_info() != 3533 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_keccak256() != 17749 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_public_key_from_private_key_k256() != 2943 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_recover_address() != 45923 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_recover_public_key_k256_keccak256() != 59591 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_recover_public_key_k256_sha256() != 13070 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_sha256() != 62964 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_user_preferences_decrypt() != 4361 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_user_preferences_encrypt() != 47149 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_func_verify_k256_sha256() != 31332 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_fficonversations_create_group() != 45500 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_fficonversations_list() != 44067 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_fficonversations_stream() != 60583 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_fficonversations_sync() != 62598 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_add_members() != 24978 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_created_at_ns() != 58515 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_find_messages() != 61973 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_id() != 35243 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_is_active() != 27808 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_list_members() != 15786 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_remove_members() != 1645 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_send() != 55957 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_stream() != 7482 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffigroup_sync() != 9422 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffistreamcloser_end() != 47211 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffistreamcloser_is_closed() != 37884 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffiv2apiclient_batch_query() != 10812 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffiv2apiclient_publish() != 13419 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffiv2apiclient_query() != 7220 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffiv2apiclient_set_app_version() != 23872 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffiv2apiclient_subscribe() != 36355 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffiv2subscription_end() != 47726 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffiv2subscription_next() != 47515 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffiv2subscription_update() != 52988 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffixmtpclient_account_address() != 65151 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffixmtpclient_can_message() != 28819 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffixmtpclient_conversations() != 31628 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffixmtpclient_register_identity() != 64634 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffixmtpclient_text_to_sign() != 25727 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffiinboxowner_get_address() != 2205 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffiinboxowner_sign() != 47939 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffilogger_log() != 56011 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_fficonversationcallback_on_conversation() != 1220 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_xmtpv3_checksum_method_ffimessagecallback_on_message() != 13573 {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiInitContinuationCallback()
    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}
